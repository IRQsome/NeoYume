CON ' Header
''
''   ###    ### #########   ######       #####    ### ####   ### ###          ### #########
''    ###    #   ##     #  ##    ##        ##     #    ##     #   ###        ###   ##     #
''    # ##   #   ##  #    ##      ##    #   ##   #     ##     #   # ##      # ##   ##  #
''    #  ##  #   #####   ###      ###  ###   ## #      ##     #   #  ##    #  ##   #####
''    #   ## #   ##  #    ##      ##    #     ##       ##     #   #   ##  #   ##   ##  #
''    #    ###   ##      # ##    ##           ##        ##   #    #    ###    ##   ##      #
''   ###    ### #########   ######           ####        ####    ###    #    #### #########
''
''                                    MAX 256 MEGA
''                                   PROP-GEAR SPEC
''
CON ' Common Constants

MASTER_CLK = 24_100_000
CLK_MULTIPLIER = 14

'DEBUG_BAUD = 1_000_000
DEBUG_LOG_SIZE = 16*1024*1024

_CLKFREQ = MASTER_CLK * CLK_MULTIPLIER ' Ignore this unless you're debugging - final clock is set by video driver

UPPER_LOAD = $5_C000

VINT_LOCK = 9
STATIC_LOCKS = decod VINT_LOCK

PSRAM_CLK = 56
PSRAM_SELECT = 57
PSRAM_BASE = 40

PSRAM_WAIT  = 10
PSRAM_DELAY = 3

DAT ' startup code & zero page
              org
              coginit #0,##UPPER_LOAD
              orgh $14
_clkf         long 0
_clkm         long 0

_mk_init_ptr    long @mk_init ' < $1C
_drawbuffer_ptr long @draw_buffer ' < $20
_palette_ptr    long @palette32   ' < $24
_vramlo_ptr     long @vram_low    ' < $28
_vramhi_ptr     long @vram_high   ' < $2C
_zk_init_ptr    long 0 ' < $30
_lspc_load_ptr  long @lspc_entry ' < $34
_blt_load_ptr   long @blt_entry ' < $38
_opnb_load_ptr  long 0 ' < $3C
_ma_init_ptr    long @ma_entry ' < $40

curpalette_base_l long @palette32
z80_command_b byte 0
z80_reply_b   byte 0
_lspc_modereg word 0

              orgh $60
              ' control bit format is %ET_DCBA_RLDU (E=sElect,T=sTart)
io_pl1_padw   word 0 ' < $60 (populated by USB code)
io_pl2_padw   word 0 ' < $62 (populated by USB code)

              orgh $80
              ' Stuff set by upcode
_exr_prog_base  long 0 ' < $80: Lower 68k ROM
_exr_port_base  long 0 ' < $84: Upper 68k ROM
                long 0 ' < $88: Unused, something something bankswitching
_exr_bios_base  long 0 ' < $8C: BIOS ROM
_exr_adpa_base  long 0 ' < $90: ADPCM A ROM
_exr_adpb_base  long 0 ' < $94: ADPCM B ROM
_exr_char_base  long 0 ' < $98: Sprite base
_exr_fixt_base  long 0 ' < $9C: Fix tile base
_exr_z80p_base  long 0 ' < $A0: Z80 ROM



              ' mailbox for 68k ROM reads
_progrq_addr  long 0
_progrq_length long 0
_progrq_target long 0
_mk_cogatn_w  word 0
_ma_cogatn_w  word 0

              orgh $F8
video_line_ctr          long 0
video_frame_ctr         long 0


CON ' MotoKore 68000 constants

#0,MK_CARRY_BIT,MK_OVER_BIT,MK_ZERO_BIT,MK_NEG_BIT,MK_EXT_BIT

MK_SUPER_BIT = 13
MK_TRACE_BIT = 15

MK_CARRY_MASK = 1<<MK_CARRY_BIT
MK_OVER_MASK  = 1<<MK_OVER_BIT
MK_ZERO_MASK  = 1<<MK_ZERO_BIT
MK_NEG_MASK   = 1<<MK_NEG_BIT
MK_EXT_MASK   = 1<<MK_EXT_BIT

MK_SUPER_MASK = 1<<MK_SUPER_BIT
MK_TRACE_MASK = 1<<MK_TRACE_BIT


MK_ROMQUE_SIZE = 16 ' words


DAT ' MotoKore 68000 cog resident code
              org
mk_cogbase
mk_d0         long 0
mk_d1         long 0
mk_d2         long 0
mk_d3         long 0
mk_d4         long 0
mk_d5         long 0
mk_d6         long 0
mk_d7         long 0
mk_a0         long 0
mk_a1         long 0
mk_a2         long 0
mk_a3         long 0
mk_a4         long 0
mk_a5         long 0
mk_a6         long 0
mk_a7         long 0

mk_othersp    long 0
mk_sr         long 0

mk_nibble_impl_tbl
              long mk_nibble_0 ' 0 (immediate ops)
              long mk_nibble_1 ' 1 (MOVE BYTE)
              long mk_nibble_2 ' 2 (MOVE LONG)
              long mk_nibble_3 ' 3 (MOVE WORD)
              long mk_nibble_4 ' 4 (weird stuff idk)
              long mk_nibble_5 ' 5 (ADDQ/SUBQ and also Scc/DBcc)
              long mk_nibble_6 ' 6 (branches)
              long mk_nibble_7 ' 7 (MOVEQ)
              long mk_nibble_8 ' 8 (OR and stuffs)
              long mk_nibble_9 ' 9 (subtracts)
              long mk_nibble_A ' A (LINE A EMULATOR TRAP)
              long mk_nibble_B ' B (CMP and EOR)
              long mk_nibble_C ' C (AND or stuffs)
              long mk_nibble_D ' D (adds)
              long mk_nibble_E ' E (Bit shifts)
              long mk_nibble_F ' F (LINE F EMULATOR TRAP)


mk_condition_truth_table
              '' Remember, status register is %XNZVC
              long $10001 * %1111_1111_1111_1111 '' %0000 : True
              'long $10001 * %0000_0000_0000_0000 '' %0001 : False
              long $10001 * %0000_0101_0000_0101 '' %0010 : High
              'long $10001 * %1111_1010_1111_1010 '' %0011 : Low or same
              long $10001 * %0101_0101_0101_0101 '' %0100 : carry clear
              'long $10001 * %1010_1010_1010_1010 '' %0101 : carry set
              long $10001 * %0000_1111_0000_1111 '' %0110 : not equal
              'long $10001 * %1111_0000_1111_0000 '' %0111 : equal
              long $10001 * %0011_0011_0011_0011 '' %1000 : overflow clear
              'long $10001 * %1100_1100_1100_1100 '' %1001 : overflow set
              long $10001 * %0000_0000_1111_1111 '' %1010 : plus
              'long $10001 * %1111_1111_0000_0000 '' %1011 : minus
              long $10001 * %1100_1100_0011_0011 '' %1100 : greater or equal (N==V)
              'long $10001 * %0011_0011_1100_1100 '' %1101 : less than (N!=V)
              long $10001 * %0000_1100_0000_0011 '' %1110 : greater than (N==V)&!Z (???)
              'long $10001 * %1111_0011_1111_1100 '' %1111 : less or equal (N!=V)|Z (???)

mk_shift_impl_tbl
              long mk_do_asr
              long mk_do_asl
              long mk_do_lsr
              long mk_do_lsl
              long mk_do_roxr
              long mk_do_roxl
              long mk_do_ror
              long mk_do_rol

mk_flowop_impl_tbl
              long mk_hub_reset
              long mk_hub_nop
              long mk_hub_stop
              long mk_hub_rte
              long mk_illegal
              long mk_hub_rts
              long mk_hub_trapv
              long mk_hub_rtr

mk_setup_ea8_tab
              long mk_setup_rom_common + %0_00000_111000_1100_110_0<<10         ' $0x_xxxx (PROG ROM)
              long mk_setup_ram_common + %0_11_11_00_00<<10                     ' $1x_xxxx (WORK RAM)
              long mk_setup_rom_common + %0_00000_110100_1111_110_0<<10         ' $2x_xxxx (PORT ROM)
              long mk_setup_io8                                                 ' $3x_xxxx (I/O)
              long mk_setup_palette8 + %0_1111_1111_0000<<10                    ' $4x_xxxx (PALETTE)
              long mk_setup_palette8 + %0_1111_1111_0000<<10                    ' $5x_xxxx (PALETTE)
              long mk_setup_palette8 + %0_1111_1111_0000<<10                    ' $6x_xxxx (PALETTE)
              long mk_setup_palette8 + %0_1111_1111_0000<<10                    ' $7x_xxxx (PALETTE)
              long mk_setup_memcard8                                            ' $8x_xxxx (MEMCARD (not present))
              long mk_setup_memcard8                                            ' $9x_xxxx (MEMCARD (not present))
              long mk_setup_memcard8                                            ' $Ax_xxxx (MEMCARD (not present))
              long mk_setup_memcard8                                            ' $Bx_xxxx (MEMCARD (not present))
              long mk_setup_rom_common + %0_00000_001110_1111_110_0<<10         ' $Cx_xxxx (BIOS ROM)
              long mk_setup_nvram8                                              ' $Dx_xxxx (NVRAM (not present))
              long mk_setup_nothing8                                            ' $Ex_xxxx (unmapped)
              long mk_setup_nothing8                                            ' $Fx_xxxx (unmapped)
mk_setup_ea16_tab
              long mk_setup_rom_common + %0_00000_111000_1010_101_0<<10         ' $0x_xxxx (PROG ROM)
              long mk_setup_ram_common + %0_11_00_11_00<<10                     ' $1x_xxxx (WORK RAM)
              long mk_setup_rom_common + %0_00000_110100_1111_101_0<<10         ' $2x_xxxx (PORT ROM)
              long mk_setup_io16                                                ' $3x_xxxx (I/O)
              long mk_setup_palette16 + %0_1111_0000<<10                        ' $4x_xxxx (PALETTE)
              long mk_setup_palette16 + %0_1111_0000<<10                        ' $5x_xxxx (PALETTE)
              long mk_setup_palette16 + %0_1111_0000<<10                        ' $6x_xxxx (PALETTE)
              long mk_setup_palette16 + %0_1111_0000<<10                        ' $7x_xxxx (PALETTE)
              long mk_setup_memcard16                                           ' $8x_xxxx (MEMCARD (not present))
              long mk_setup_memcard16                                           ' $9x_xxxx (MEMCARD (not present))
              long mk_setup_memcard16                                           ' $Ax_xxxx (MEMCARD (not present))
              long mk_setup_memcard16                                           ' $Bx_xxxx (MEMCARD (not present))
              long mk_setup_rom_common + %0_00000_001110_1111_101_0<<10         ' $Cx_xxxx (BIOS ROM)
              long mk_setup_nvram16                                             ' $Dx_xxxx (NVRAM (not present))
              long mk_setup_nothing16                                           ' $Ex_xxxx (unmapped)
              long mk_setup_nothing16                                           ' $Fx_xxxx (unmapped)
mk_setup_ea32_tab
              long mk_setup_rom_common + %0_00000_111000_0110_011_0<<10         ' $0x_xxxx (PROG ROM)
              long mk_setup_ram_common  + %0_00_11_11_00<<10                    ' $1x_xxxx (WORK RAM)
              long mk_setup_rom_common + %0_00000_110100_1111_011_0<<10         ' $2x_xxxx (PORT ROM)
              long mk_setup_io32                                                ' $3x_xxxx (I/O)
              long mk_setup_palette32 + %0_0000<<10                             ' $4x_xxxx (PALETTE)
              long mk_setup_palette32 + %0_0000<<10                             ' $5x_xxxx (PALETTE)
              long mk_setup_palette32 + %0_0000<<10                             ' $6x_xxxx (PALETTE)
              long mk_setup_palette32 + %0_0000<<10                             ' $7x_xxxx (PALETTE)
              long mk_setup_memcard32                                           ' $8x_xxxx (MEMCARD (not present))
              long mk_setup_memcard32                                           ' $9x_xxxx (MEMCARD (not present))
              long mk_setup_memcard32                                           ' $Ax_xxxx (MEMCARD (not present))
              long mk_setup_memcard32                                           ' $Bx_xxxx (MEMCARD (not present))
              long mk_setup_rom_common + %0_00000_001110_1111_011_0<<10         ' $Cx_xxxx (BIOS ROM)
              long mk_setup_nvram32                                             ' $Dx_xxxx (NVRAM (not present))
              long mk_setup_nothing32                                           ' $Ex_xxxx (unmapped)
              long mk_setup_nothing32                                           ' $Fx_xxxx (unmapped)


mk_rd_nothing
        _ret_ mov mk_memvalue,#0

mk_rd8_reg
        _ret_ getbyte mk_memvalue,0-0,#0
mk_wr8_reg
        _ret_ setbyte 0-0,mk_memvalue,#0
mk_rd16_reg
        _ret_ getword mk_memvalue,0-0,#0
mk_wr16_reg
        _ret_ setword 0-0,mk_memvalue,#0
mk_rd32_reg
        _ret_ mov mk_memvalue,0-0
mk_wr32_reg
        _ret_ mov 0-0,mk_memvalue

mk_rd8_rom
              setq #2
              wrlong mk_romio_addr,#_progrq_addr
              cogatn mk_romio_atnval
              waitatn
mk_rd8_ram
        _ret_ rdbyte mk_memvalue,mk_eacache
mk_wr8_ram
              'call #mk_debug_wrchk8
        _ret_ wrbyte mk_memvalue,mk_eacache

mk_rd16_rom
              setq #2
              wrlong mk_romio_addr,#_progrq_addr
              cogatn mk_romio_atnval
              waitatn
mk_rd16_ram
              rdword mk_memvalue,mk_eacache
        _ret_ movbyts mk_memvalue,#%%3201
mk_wr16_ram
              'call #mk_debug_wrchk16
              movbyts mk_memvalue,#%%3201
        _ret_ wrword mk_memvalue,mk_eacache

mk_rd32_rom
              setq #2
              wrlong mk_romio_addr,#_progrq_addr
              cogatn mk_romio_atnval
              waitatn
mk_rd32_ram
              rdlong mk_memvalue,mk_eacache
        _ret_ movbyts mk_memvalue,#%%0123
mk_wr32_ram
              'call #mk_debug_wrchk32
              movbyts mk_memvalue,#%%0123
        _ret_ wrlong mk_memvalue,mk_eacache

mk_wrrom      ret ' obviously nothing

mk_rdimm
        _ret_ mov mk_memvalue,mk_eacache


mk_longio_tmp long 0

mk_rd32_io
              call #mk_rd16_io
              getword mk_longio_tmp,mk_memvalue,#0
              add mk_eacache,#2
              call #mk_rd16_io
        _ret_ setword mk_memvalue,mk_longio_tmp,#1
mk_wr32_io
              mov mk_longio_tmp,mk_memvalue
              shr mk_memvalue,#16
              call #mk_wr16_io
              add mk_eacache,#2
              getword mk_memvalue,mk_longio_tmp,#0
              ' fall through
mk_wr16_io
              getnib pa,mk_effaddr,#4
              shr pa,#1
              jmprel pa
              jmp #.todo                        ' C0_xxxx (watchdog)
              jmp #iog_z80port_wr16             ' C2_xxxx (Z80 command)
              jmp #.undecoded                   ' C4_xxxx (nothing?)
              jmp #.undecoded                   ' C6_xxxx (nothing?)
              jmp #.undecoded                   ' C8_xxxx (nothing?)
              jmp #iog_latch_wr16               ' CA_xxxx (latches)
              jmp #iog_lspc_wr16                ' CC_xxxx (LSPC)
              'jmp #.undecoded                  ' CE_xxxx (nothing?)

.undecoded
              debug("undecoded IO WORD WRITE: ",uhex_(mk_effaddr),uhex_long(mk_virtualpc))
.todo
              ret wcz ' undecoded IO?

mk_wr8_io
              'debug("mk_wr8_io ",uhex(mk_effaddr))
              getnib pa,mk_effaddr,#4
              shr pa,#1
              jmprel pa
              jmp #.todo                        ' C0_xxxx (watchdog)
              jmp #iog_z80port_wr8              ' C2_xxxx (Z80 command)
              jmp #.undecoded                   ' C4_xxxx (nothing?)
              jmp #.undecoded                   ' C6_xxxx (nothing?)
              jmp #.undecoded                   ' C8_xxxx (nothing?)
              jmp #iog_latch_wr8                ' CA_xxxx (latches)
              jmp #iog_lspc_wr8                 ' CC_xxxx (LSPC)
              'jmp #.undecoded                  ' CE_xxxx (nothing?)
.undecoded
.todo
              ret wcz

mk_rd16_io
              getnib pa,mk_effaddr,#4
              shr pa,#1
              jmprel pa
              jmp #iog_p1stuff_rd16             ' C0_xxxx (P1 controls,etc)
              jmp #iog_status_a_rd16            ' C2_xxxx (Status A / Z80 reply)
              jmp #iog_p2stuff_rd16             ' C4_xxxx (P2 controls,etc)
              jmp #.undecoded                   ' C6_xxxx (nothing?)
              jmp #iog_status_b_rd16            ' C8_xxxx (Status B)
              jmp #.undecoded                   ' CA_xxxx (latches)
              jmp #iog_lspc_rd16                ' CC_xxxx (LSPC)
              'jmp #.undecoded                  ' CE_xxxx (nothing?)

.undecoded
              debug("undecoded IO WORD READ: ",uhex(mk_effaddr))
              mov mk_memvalue,#0 ' TODO
              ret wcz ' undecoded IO?


mk_rd8_io
              bitl mk_eacache,#0 wcz
              call #mk_rd16_io
              bitc mk_eacache,#0
        if_nc getbyte mk_memvalue,mk_memvalue,#1
        if_c  getbyte mk_memvalue,mk_memvalue,#0
              ret wcz


mk_rd8_vector
              getbyte pa,mk_effaddr,#0
              xor pa,#3
              add pa,mk_vectors_ptr
        _ret_ rdbyte mk_memvalue,pa
mk_rd16_vector
              getbyte pa,mk_effaddr,#0
              xor pa,#2
              add pa,mk_vectors_ptr
        _ret_ rdword mk_memvalue,pa
mk_rd32_vector
              getbyte pa,mk_effaddr,#0
              bitl pa,#1 wcz
              add pa,mk_vectors_ptr
              rdlong mk_memvalue,pa
              add pa,#4
        if_c  rdlong pa,pa
        if_c  rolword mk_memvalue,pa,#1
              ret wcz

mk_wr_sr
              xor mk_memvalue,mk_sr
              testn mk_memvalue,#255 wz
              xor mk_memvalue,mk_sr
              testb mk_sr,#MK_SUPER_BIT wc
  if_nz_or_nc jmp #mk_hub_wr_sr

mk_wr_ccr
              setq #%11111
              muxq mk_sr,mk_memvalue
              ret wcz
mk_rd_sr
        _ret_ mov mk_memvalue,mk_sr


mk_illegal
              debug("ILLEGAL INSTRUCTION ",uhex_word(mk_opword),uhex_long(mk_virtualpc))
              'drvh #38
              mov pb,#$10
              jmp #mk_hub_trapit


mk_nextop
              'debug("registers: ",ubin_word(mk_sr),13,uhex_reg_array(#mk_d0,#8),13,uhex_reg_array(#mk_a0,#8))
              'debug("last 16 RAM bytes: ",uhex_byte_array(#main_ram + $FFF0,#16))
              'tjnz mk_debug_ctr,#mk_nextop_nohook
              'jatn mk_cogatnptr
mk_ihook1     nop
mk_ihook2     nop
mk_nextop_nohook
              'cmp mk_virtualpc,mk_debug_tripwire wz
        'if_z drvh #38
       'if_z  mov mk_debug_tripwire,#0
       'if_z   mov mk_debug_ctr,#1
              'debug("getting op with ",uhex_long(mk_virtualpc))
              'debug(uhex_long_(mk_virtualpc))
              'debug(uhex_word_array(#@fake_rom+$200,#4))
              call mk_getopf
              'debug("got op: ",uhex_word(mk_opword))
              debug("got op: ",uhex_word_(mk_opword)," before ",uhex_long_(mk_virtualpc))
              'tjnz mk_debug_tripwire,#.no_trace
              'tjz mk_debug_ctr,#.no_trace
              'sub mk_debug_ctr,#1
              'cmp mk_debug_tripwire,mk_virtualpc wz
        'if_nz jmp #.no_trace
              'debug("tripwired' ",uhex_byte_array(#@zbus_status,#1),uhex_long(mk_virtualpc))
              'call #mk_check_core_integrity
              'debug("got: ",uhex_word_(mk_opword)," before ",uhex_long_(mk_virtualpc),uhex_long(mk_d2,mk_a0,mk_a1))
              'debug("registers: ",ubin_word(mk_sr),13,uhex_reg_array(#mk_d0,#8),13,uhex_reg_array(#mk_a0,#8))

              'debug("got op: ",uhex_word(mk_opword)," before ",uhex_long(mk_virtualpc),uhex_long(mk_a3))
              'waitx ##174_00
.no_trace
              push #mk_nextop
              getnib mk_memtmp0,mk_opword,#3
              altd mk_memtmp0,#mk_nibble_impl_tbl
              jmp 0-0

mk_irq1ptr    long @mk_hub_irq1
mk_irq2ptr    long @mk_hub_irq2
'mk_cogatnptr long @mk_hub_cogatn


mk_write_second_reg_or_ea '' for ops that have two directional modes
              testb mk_opword,#8 wc
        if_c  jmp mk_writef
mk_write_second_reg
              neg pb,#1
              shr pb,mk_shiftit
              setq pb
              and mk_opword,mk_dreg_mask ' assume we don't need it anymore
              alti mk_opword,#%000_100_000
        _ret_ muxq 0-0,mk_memvalue


mk_nibble_0   ' Immediate ops (decode headache!)
              testb mk_opword,#8 wc
              test mk_opword,#%110_000 wz
              testb mk_opword,#3 andz
        if_c_and_z jmp #mk_hub_movep
        if_c  jmp #.register_bitop ' not actually an immediate op...
              getnib mk_optmp2,mk_opword,#2
              cmp mk_optmp2,#%1000 wz
        if_z  jmp #.imm_bitop
              ' ok, we know it's a sized ***I type op
              mov pb,mk_opword
              call #mk_getopimm_auto
              'debug("xxxI type op... imm is ",uhex_long(mk_optmp1))
              mov pb,mk_opword
              and pb,#%111_111
              cmp pb,#%111_100 wz ' <- if Z, is op to SR/CCR
        if_z  mov mk_readf,#mk_rd_sr
        if_z  mov mk_shiftit,#16
        if_z  testb mk_opword,#6 wc
        if_z_and_c  mov mk_writef,#mk_wr_sr
        if_z_and_nc mov mk_writef,#mk_wr_ccr
        if_nz callpb mk_opword,#mk_setup_operand_auto

              call mk_readf
              cmp mk_optmp2,#%1100 wz
        if_z  jmp #mk_cmp_swapped ' CMPI (doesn't write)
              push mk_writef ' setup write return
              cmp mk_optmp2,#%0110 wz
        if_z  jmp #mk_add_common ' ADDI
              cmp mk_optmp2,#%0100 wz
        if_z  jmp #mk_sub_common ' SUBI
              ' ok, only logic ops left
              setr mk_thelogicop,#%0101000_01 ' P2 AND WZ opcode (assume this if no other logic op)
              cmp mk_optmp2,#%0000 wz
        if_z  setr mk_thelogicop,#%0101010_01 ' P2 OR WZ opcode
              cmp mk_optmp2,#%1010 wz
        if_z  setr mk_thelogicop,#%0101011_01 ' P2 XOR WZ opcode
              jmp #mk_multilogic_common

.imm_bitop
              push #.bitop_common
              jmp #mk_getopimm8
.register_bitop
              mov pb,mk_opword
              shr pb,#9
              and pb,#7
              alts pb,#mk_d0
              mov mk_optmp1,0-0
.bitop_common
              test mk_opword,#%110_000 wz ' Register op?
              mov pb,mk_opword
        if_z  call #mk_setup_reg32
        if_nz and mk_optmp1,#7
        if_nz call #mk_setup_operand8
              call mk_readf
              'debug("doing bitop with ",uhex_byte(mk_optmp1),uhex_long(mk_memvalue))
              testbn mk_memvalue,mk_optmp1 wc
              bitc mk_sr,#MK_ZERO_BIT
              testb mk_opword,#6 wz
              testb mk_opword,#7 wc
        if_00 ret ' BTST
              and mk_optmp1,#31 ' bitfield-sensitive ops ahead
        if_01 bitnot mk_memvalue,mk_optmp1 ' BCHG
        if_1x bitz mk_memvalue,mk_optmp1 ' BCLR/BSET
              'debug("bitop result ",uhex_long(mk_memvalue))
              jmp mk_writef



mk_cmp
              callpb mk_opword,#mk_setup_operand_auto
              call mk_readf
              push #mk_cmp_common
              jmp #mk_get_second_reg

mk_cmp_swapped
              xor mk_memvalue,mk_optmp1
              xor mk_optmp1,mk_memvalue
              xor mk_memvalue,mk_optmp1
mk_cmp_common
              'debug("in mk_cmp_common ",uhex_long(mk_d0),uhex_long(mk_memvalue),uhex_long(mk_optmp1),udec(mk_shiftit))
              shl mk_memvalue,mk_shiftit
              shl mk_optmp1,mk_shiftit
              ' NOTE: the operands are swapped compared to sub_common
              ' generate stupid overflow flag
              mov mk_optmp0,mk_optmp1
              subs mk_optmp0,mk_memvalue wc
              testb mk_optmp0,#31 xorc
              bitc mk_sr,#MK_OVER_BIT
              ' do actual sub
              sub mk_optmp1,mk_memvalue wcz
              bitc mk_sr,#MK_CARRY_BIT
              bitz mk_sr,#MK_ZERO_BIT
              testb mk_optmp0,#31 wc
        _ret_ bitc mk_sr,#MK_NEG_BIT


mk_cmpa
              testb mk_opword,#8 wc ' long sized?
        if_nc callpb mk_opword,#mk_setup_operand16
        if_c  callpb mk_opword,#mk_setup_operand32
              call mk_readf
        if_nc signx mk_memvalue,#15
              mov pb,mk_opword
              shr pb,#9
              and pb,#7
              alts pb,#mk_a0
              mov mk_optmp1,0-0
              mov mk_shiftit,#0
              jmp #mk_cmp_common




mk_nibble_9
mk_nibble_D
              ' ADD/SUB (X/A)
              ' check for ADDA/SUBA
              test mk_opword,#%11_000_000 wcz
        if_00 jmp #mk_addsuba
              ' check for ADDX/SUBX
              test mk_opword,#%110_000 wz
              testb mk_opword,#8 andz
        if_z  jmp #mk_hub_addsubx

              ' Okay, normal ADD/SUB
              callpb mk_opword,#mk_setup_operand_auto
              call mk_readf
              call #mk_get_second_reg
              push #mk_write_second_reg_or_ea
              testb mk_opword,#14 wc ' C = ADD,NC = SUB ?
        if_nc jmp #mk_sub_withdir
              ' fall through
mk_add_common
              shl mk_memvalue,mk_shiftit
              shl mk_optmp1,mk_shiftit
              ' generate stupid overflow flag
              mov mk_optmp0,mk_optmp1
              adds mk_optmp0,mk_memvalue wc
              testb mk_optmp0,#31 xorc
              bitc mk_sr,#MK_OVER_BIT
              ' do actual add
              add mk_memvalue,mk_optmp1 wcz
              muxc mk_sr,#MK_CARRY_MASK|MK_EXT_MASK
              bitz mk_sr,#MK_ZERO_BIT
              testb mk_optmp0,#31 wc
              bitc mk_sr,#MK_NEG_BIT

        _ret_  shr mk_memvalue,mk_shiftit

mk_sub_withdir
              ' if dir bit clear, swap operands
              testb mk_opword,#8 wc
        if_nc xor mk_memvalue,mk_optmp1
        if_nc xor mk_optmp1,mk_memvalue
        if_nc xor mk_memvalue,mk_optmp1
mk_sub_common
              'debug("in mk_sub_common ",uhex_long(mk_d0),uhex_long(mk_memvalue),uhex_long(mk_optmp1),udec(mk_shiftit))
              shl mk_memvalue,mk_shiftit
              shl mk_optmp1,mk_shiftit

              ' generate stupid overflow flag
              mov mk_optmp0,mk_memvalue
              subs mk_optmp0,mk_optmp1 wc
              testb mk_optmp0,#31 xorc
              bitc mk_sr,#MK_OVER_BIT
              ' do actual sub
              sub mk_memvalue,mk_optmp1 wcz
              muxc mk_sr,#MK_CARRY_MASK|MK_EXT_MASK
              bitz mk_sr,#MK_ZERO_BIT
              testb mk_optmp0,#31 wc
              bitc mk_sr,#MK_NEG_BIT

        _ret_  shr mk_memvalue,mk_shiftit

mk_addsuba
              setq mk_dreg_mask
              muxq .adda_op,mk_opword
              testb mk_opword,#8 wc ' long sized?
        if_nc callpb mk_opword,#mk_setup_operand16
        if_c  callpb mk_opword,#mk_setup_operand32
              call mk_readf
              'debug("in mk_adda: ",uhex_long(mk_memvalue))
        if_nc signx mk_memvalue,#15
              testb mk_opword,#14 wc ' C = ADDA,NC = SUBA ?
.adda_op _ret_ sumnc mk_a0,mk_memvalue


' Memory R/W primitives
mk_setup_operand_auto ' with ea-supplying op in pb
                 ' make sure size field is not %11 (will be treated as 16bit)
              testb pb,#6 wc
        if_c  jmp #mk_setup_operand16
              testb pb,#7 wc
        if_c  jmp #mk_setup_operand32
              ' Fall through!
mk_setup_operand8
              'debug("in mk_setup_operand8 ",ubin(pb))
              mov mk_shiftit,#24
mk_setup_operand8_move
              test pb,#%110_000 wz
        if_z  jmp #mk_setup_reg8
              and pb,#%00_111_111
              cmp pb,#%00_111_100 wc
        if_ae jmp #mk_setup_imm8
              call #mk_compute_ea
mk_setup_ea8
              'debug("in mk_setup_ea8 ",uhex_long(mk_effaddr))
              getnib pb,mk_effaddr,#5
              altd pb,#mk_setup_ea8_tab
              execf 0-0



mk_setup_operand16
              'debug("in mk_setup_operand16 ",ubin(pb))
              mov mk_shiftit,#16
mk_setup_operand16_move
              test pb,#%110_000 wz
        if_z  jmp #mk_setup_reg16
              and pb,#%00_111_111
              cmp pb,#%00_111_100 wc
        if_ae jmp #mk_setup_imm16
              or  pb,#%01_000_000
              call #mk_compute_ea
mk_setup_ea16
              testb mk_effaddr,#0 wc
        if_c  jmp #mk_address_error
              getnib pb,mk_effaddr,#5
              altd pb,#mk_setup_ea16_tab
              execf 0-0


mk_setup_operand32
              mov mk_shiftit,#0
mk_setup_operand32_move
              test pb,#%110_000 wz
        if_z  jmp #mk_setup_reg32
              and pb,#%00_111_111
              cmp pb,#%00_111_100 wc
        if_ae jmp #mk_setup_imm32
              or  pb,#%10_000_000
              call #mk_compute_ea
mk_setup_ea32
              testb mk_effaddr,#0 wc
        if_c  jmp #mk_address_error
              getnib pb,mk_effaddr,#5
              altd pb,#mk_setup_ea32_tab
              execf 0-0


mk_ea_impl_tbl
              long mk_ea_direct
              long mk_ea_postinc
              long mk_ea_predec
              long mk_ea_displace
              long mk_ea_index
              long mk_ea_headache


mk_multilogic
              call #mk_get_second_reg
              callpb mk_opword,#mk_setup_operand_auto
              call mk_readf
              push #mk_write_second_reg_or_ea
mk_multilogic_common
              shl mk_memvalue,mk_shiftit
              shl mk_optmp1,mk_shiftit

mk_thelogicop and mk_memvalue,mk_optmp1 wz

              bitz mk_sr,#MK_ZERO_BIT
              testb mk_memvalue,#31 wz
              bitz mk_sr,#MK_NEG_BIT
              andn mk_sr,#MK_CARRY_MASK|MK_OVER_MASK
        _ret_ shr mk_memvalue,mk_shiftit


mk_getop_ram
              mov mk_memtmp0,mk_virtualpc
              add mk_virtualpc,#2
              setword mk_memtmp0,#1,#1 ' main_ram!
              rdword mk_opword,mk_memtmp0
        _ret_ movbyts mk_opword,#%%3201

mk_getop_rom
              'debug("in getop_rom with ",udec(mk_romque_left))
              djf mk_romque_left,#mk_romque_refill
              add mk_virtualpc,#2
              rdword mk_opword,ptra++
              movbyts mk_opword,#%%3201
              ret wcz
mk_romque_left    long 0



mk_romio_area_ptr long @mk_romio_area
mk_romio_area_ptr_shr2 long @mk_romio_area >> 2
mk_romque_area_ptr long @mk_romque_area
mk_dreg_mask      long %111_000_000_000

mk_vectors_mask long $FF_FF80
mk_bit31      long 1<<31


mk_cogvar_start

mk_debug_tripwire long $00173E
mk_debug_ctr  long 0

mk_vram_curr  long 0
mk_vram_modulo long 0

mk_vectors_ptr res 1

mk_prog_base    res 1
mk_port_base    res 1
mk_bios_base    res 1

mk_virtualpc  res 1 ' PC in virtual space
mk_effaddr    res 1 ' calculated effective address
mk_shiftit    res 1 ' operand MSB shift
mk_branchdisplace res 1 ' branch target
mk_opword     res 1 ' opcode

mk_readf      res 1 ' operand read pointer
mk_writef     res 1 ' operand write pointer
mk_getopf     res 1 ' opword get pointer

mk_optmp0     res 1
mk_optmp1     res 1
mk_optmp2     res 1

mk_eatmp0     res 1
mk_eatmp1     res 1

mk_romio_addr   res 1
mk_romio_length res 1
mk_romio_target res 1

mk_romqueio_addr res 1
mk_romqueio_length res 1
mk_romqueio_target res 1

mk_romque_base res 1
mk_romque_zerox res 1

mk_romio_atnval res 1


              fit $1F0
              org $1F0

mk_memtmp0    res 1
mk_memtmp1    res 1
mk_memtmp2    res 1
mk_memtmp3    res 1
mk_memvalue   res 1 ' memory read/write value
mk_eacache    res 1 ' remapped EA
              fit $1F6
DAT ' MotoKore 68000 LUT resident code
mk_lutbase
              org 512


mk_move_shoot_the_shit ' handle all the common MOVE stuff
               ' Doing MOVEA?
              test mk_opword,#%110_000_000 wz
              testb mk_opword,#6 andz
        if_z  jmp #.movea
              signx mk_memvalue,pa wcz
              bitc mk_sr,#MK_NEG_BIT
              bitz mk_sr,#MK_ZERO_BIT
              andn mk_sr,#MK_OVER_MASK|MK_CARRY_MASK
.mangle_ea2   ' format for second operand is stupid
              setnib mk_opword,#0,#3
              mov pa,mk_opword
              and pa,#%111_000_000
              shl pa,#6
              or mk_opword,pa
        _ret_ shr mk_opword,#9
.movea
              shr mk_opword,#9
              and mk_opword,#7
              altr mk_opword,#mk_a0
              signx mk_memvalue,pa
              jmp #mk_nextop ' don't need the rest of the op


mk_nibble_1 ' MOVE (byte)
              callpb mk_opword,#mk_setup_operand8_move
              call mk_readf
              callpa #7,#mk_move_shoot_the_shit
              callpb mk_opword,#mk_setup_operand8_move
              'debug("in move.b, writing ",uhex_byte(mk_memvalue)," to ",uhex_long(mk_effaddr))
              jmp mk_writef

mk_nibble_3 ' MOVE (word)
              'debug("in move.w")
              callpb mk_opword,#mk_setup_operand16_move
              call mk_readf
              callpa #15,#mk_move_shoot_the_shit
              callpb mk_opword,#mk_setup_operand16_move
              'debug("in move.w, writing ",uhex_word(mk_memvalue)," to ",uhex_long(mk_effaddr))
              jmp mk_writef

mk_nibble_2 ' MOVE (long)
              callpb mk_opword,#mk_setup_operand32_move
              call mk_readf
              callpa #31,#mk_move_shoot_the_shit
              callpb mk_opword,#mk_setup_operand32_move
              jmp mk_writef


mk_nibble_5 ' ADDQ/SUBQ/Scc/DBcc
              test mk_opword,#%11_000_000 wcz
        if_00 jmp #mk_nibble_5_not_addsub
              ' get operand
              mov mk_optmp1,mk_opword
              shr mk_optmp1,#9 wc ' C = SUBQ, NC = ADDQ
              and mk_optmp1,#7 wz
        if_z  mov mk_optmp1,#8
              ' Check if An reg
              test mk_opword,#%110_000 wz
              testb mk_opword,#3 andz
        if_z  jmp #.addsubq_areg
              callpb mk_opword,#mk_setup_operand_auto
              call mk_readf
              push mk_writef
        if_c  jmp #mk_sub_common
              jmp #mk_add_common

.addsubq_areg
              and mk_opword,#7
              altd mk_opword,#mk_a0
        _ret_ sumc 0-0,mk_optmp1


mk_nibble_5_not_addsub
              ' Check if DBCC
              test mk_opword,#%110_000 wz
              testb mk_opword,#3 andz
        if_z  jmp #mk_dbcc
              ' got SCC
              callpb mk_opword,#mk_setup_operand8
              call mk_readf ' <- yes, this is stupid but accurate
              getnib pb,mk_opword,#2
              shr pb,#1 wc
              altd pb,#mk_condition_truth_table
              testb 0-0,mk_sr xorc
              muxc mk_memvalue,#255
              jmp mk_writef


mk_romque_refill
              mov mk_romqueio_target,mk_romque_area_ptr
              mov mk_romqueio_length,#MK_ROMQUE_SIZE/2
              mov mk_romque_left,#MK_ROMQUE_SIZE wcz ' clear C and Z
              mov mk_romqueio_addr,mk_virtualpc
              zerox mk_romqueio_addr,mk_romque_zerox' Limit to 1 MB range
              add mk_romqueio_addr,mk_romque_base
              ' Handle not long-aligned access
              rczr mk_romqueio_addr wcz
        if_z  jmp #mk_address_error_debug ' TODO: maybe make AE function code read program in this case?
        if_c  sub  mk_romqueio_target,#2
        if_c  add  mk_romqueio_length,#1
              setq #2
              wrlong mk_romqueio_addr,#_progrq_addr
              cogatn mk_romio_atnval
              mov ptra,mk_romque_area_ptr
              waitatn
              jmp #mk_getop_rom


mk_compute_ea ' CAN AND WILL OVERWRITE FLAGS
              'debug("In mk_compute_ea ",ubin(pb))
              mov mk_eatmp1,pb
              shr mk_eatmp1,#3 wcz '< just to drive the point home
              and mk_eatmp1,#7
              altd mk_eatmp1,#mk_ea_impl_tbl - 2 ' non-memory modes shouldn't appear here
              jmp 0-0

mk_ea_direct
              and pb,#7
              alts pb,#mk_a0
        _ret_ mov mk_effaddr,0-0

mk_nibble_E   ' shifts
              andn mk_sr,#MK_OVER_MASK|MK_CARRY_MASK ' These are cleared by default
              test mk_opword,#%11_000_000 wcz
        if_00 jmp #.memshift
              mov pb,mk_opword
              andn pb,#%00_111_000
              call #mk_setup_operand_auto
              xor mk_shiftit,#31 ' <- change into MSB's index
              ' get shift amount
              call #mk_get_second_reg
              testb mk_opword,#5 wc
        if_nc mov mk_optmp1,pb wz
  if_nc_and_z mov mk_optmp1,#8
              and mk_optmp1,#63 wz
              ' move shift mode bits into place
              testb mk_opword,#8 wz
              shr  mk_opword,#2
              bitz mk_opword,#0
.do_shift
              call mk_readf
              'debug("regshift amount is ",udec(mk_optmp1),"also, ",udec(mk_shiftit)," shift val is ",uhex_long(mk_memvalue))
              and mk_opword,#7
              altd mk_opword,#mk_shift_impl_tbl
              call 0-0
.done
              zerox mk_memvalue,mk_shiftit wz
              testb mk_memvalue,mk_shiftit wc
              bitc mk_sr,#MK_NEG_BIT
              bitz mk_sr,#MK_ZERO_BIT
              'debug("shift result ",uhex_long(mk_memvalue))
              jmp mk_writef

.memshift
              mov pb,mk_opword
              call #mk_setup_operand16
              mov mk_shiftit,#15
              mov mk_optmp1,#1
              shr mk_opword,#8 ' get shift mode bits into place
              jmp #.do_shift

mk_zeroroxx
              testb mk_sr,#MK_EXT_BIT wc
        _ret_ bitc mk_sr,#MK_CARRY_BIT
mk_zeroshift
        _ret_ bitl mk_sr,#MK_CARRY_BIT

mk_do_asr
              tjz mk_optmp1,#mk_zeroshift
              rep @.loop,mk_optmp1
              testb mk_memvalue,mk_shiftit wz
              shr mk_memvalue,#1 wc
              bitz mk_memvalue,mk_shiftit
.loop
        _ret_ muxc mk_sr,#MK_EXT_MASK|MK_CARRY_MASK

mk_do_asl
              tjz mk_optmp1,#mk_zeroshift
              rep @.loop,mk_optmp1
              testb mk_memvalue,mk_shiftit wc
              shl mk_memvalue,#1
              testb mk_memvalue,mk_shiftit wz
        if_z_ne_c bith mk_sr,#MK_OVER_BIT
.loop
        _ret_ muxc mk_sr,#MK_EXT_MASK|MK_CARRY_MASK

mk_do_lsr
              tjz mk_optmp1,#mk_zeroshift
              rep @.loop,mk_optmp1
              shr mk_memvalue,#1 wc
.loop
        _ret_ muxc mk_sr,#MK_EXT_MASK|MK_CARRY_MASK

mk_do_lsl
              tjz mk_optmp1,#mk_zeroshift
              rep @.loop,mk_optmp1
              testb mk_memvalue,mk_shiftit wc
              shl mk_memvalue,#1
.loop
        _ret_ muxc mk_sr,#MK_EXT_MASK|MK_CARRY_MASK

mk_do_ror
              tjz mk_optmp1,#mk_zeroshift
              rep @.loop,mk_optmp1
              shr mk_memvalue,#1 wc
              bitc mk_memvalue,mk_shiftit
.loop
        _ret_ muxc mk_sr,#MK_CARRY_MASK

mk_do_rol
              tjz mk_optmp1,#mk_zeroshift
              rep @.loop,mk_optmp1
              testb mk_memvalue,mk_shiftit wc
              rcl mk_memvalue,#1
.loop
        _ret_ muxc mk_sr,#MK_CARRY_MASK

mk_do_roxr
              tjz mk_optmp1,#mk_zeroroxx
              rep @.loop,mk_optmp1
              testb mk_sr,#MK_EXT_BIT wz
              shr mk_memvalue,#1 wc
              bitz mk_memvalue,mk_shiftit
              muxc mk_sr,#MK_EXT_MASK|MK_CARRY_MASK
.loop
              ret
mk_do_roxl
              tjz mk_optmp1,#mk_zeroroxx
              rep @.loop,mk_optmp1
              testb mk_sr,#MK_EXT_BIT wc
              testb mk_memvalue,mk_shiftit wz
              rcl mk_memvalue,#1
              muxz mk_sr,#MK_EXT_MASK|MK_CARRY_MASK
.loop
              ret




mk_readrom_ea32
              mov mk_romio_length,#2
              skipf #%10
mk_readrom_ea
              mov pa,mk_effaddr
              mov mk_romio_length,#1
              rczr pa wcz
              mov mk_romio_target,mk_romio_area_ptr
        if_c  sub mk_romio_target,#2
        if_z  sub mk_romio_target,#1

              jmp #$

mk_setup_nothing8
mk_setup_nothing16
mk_setup_nothing32
mk_setup_memcard8
mk_setup_memcard16
mk_setup_memcard32
mk_setup_nvram8
mk_setup_nvram16
mk_setup_nvram32
              mov  mk_readf,#mk_rd_nothing
              mov  mk_writef,#mk_wrrom
              ret wcz

mk_setup_palette8
              mov  mk_writef,##pal32_wr8
              mov  mk_readf,##pal32_rd8
mk_setup_palette16
              mov  mk_writef,##pal32_wr16
              mov  mk_readf,##pal32_rd16
mk_setup_palette32
              mov  mk_writef,##pal32_wr32
              mov  mk_readf,##pal32_rd32
              debug("mk_setup_palette canary")
              ret  wcz


mk_setup_rom_common
              mov  mk_writef,#mk_wrrom

              mov  mk_readf,#mk_rd8_rom
              mov  mk_readf,#mk_rd16_rom
              mov  mk_readf,#mk_rd32_rom

              test mk_effaddr,mk_vectors_mask wz
        if_z  mov  mk_readf,#mk_rd8_vector
        if_z  mov  mk_readf,#mk_rd16_vector
        if_z  mov  mk_readf,#mk_rd32_vector

              mov  mk_romio_addr,mk_effaddr
              zerox mk_romio_addr,#19
              add  mk_romio_addr,mk_prog_base
              add  mk_romio_addr,mk_port_base
              zerox mk_romio_addr,#16
              add  mk_romio_addr,mk_bios_base

              mov  mk_eacache,mk_romio_area_ptr_shr2 wcz ' Clear CZ
              rczr mk_romio_addr wcz
              rczl mk_eacache
              mov mk_romio_target,mk_romio_area_ptr
              mov mk_romio_length,#2
              ret  wcz

mk_setup_ram_common
              mov mk_eacache,mk_effaddr
              setword mk_eacache,#@main_ram>>16,#1

              mov  mk_readf,#mk_rd8_ram
              mov  mk_writef,#mk_wr8_ram

              mov  mk_readf,#mk_rd16_ram
              mov  mk_writef,#mk_wr16_ram

              mov  mk_readf,#mk_rd32_ram
              mov  mk_writef,#mk_wr32_ram

              ret wcz


mk_setup_reg8
              ' Address register 8 bit ops are illegal, so don't care
              and pb,#%1_111
              sets mk_rd8_reg,pb
              setd mk_wr8_reg,pb
              mov  mk_readf,#mk_rd8_reg
              mov  mk_writef,#mk_wr8_reg
              ret wcz
mk_setup_io8
              mov  mk_eacache,mk_effaddr
              zerox mk_eacache,#19
              mov  mk_readf,#mk_rd8_io
              mov  mk_writef,#mk_wr8_io
              'debug("in mk_setup_io8 ",uhex_long(mk_effaddr))
              'jmp pb wcz
              ret wcz


mk_setup_imm8
              call #mk_setup_imm16
              and mk_eacache,#255
              ret wcz

mk_setup_reg16
              'debug("in mk_setup_reg16 ",ubin(pb))
        'if_nz jmp #mk_setup_areg ' Address register is always 32 bit
              and pb,#%1_111
              sets mk_rd16_reg,pb
              setd mk_wr16_reg,pb
              mov  mk_readf,#mk_rd16_reg
              mov mk_writef,#mk_wr16_reg
              ret wcz
mk_setup_ram16
              mov mk_eacache,mk_effaddr
              setword mk_eacache,#@main_ram>>16,#1
              mov  mk_readf,#mk_rd16_ram
              mov  mk_writef,#mk_wr16_ram
              ret wcz
mk_setup_io16
              mov  mk_eacache,mk_effaddr
              zerox mk_eacache,#19
              mov  mk_readf,#mk_rd16_io
              mov  mk_writef,#mk_wr16_io
              ret wcz
mk_setup_imm16
              mov mk_eatmp0,mk_opword
              call mk_getopf
              mov mk_eacache,mk_opword
              mov mk_opword,mk_eatmp0
              mov  mk_readf,#mk_rdimm
              mov  mk_writef,#mk_illegal
              ret wcz

mk_setup_reg32
              and pb,#%1_111
              sets mk_rd32_reg,pb
              setd mk_wr32_reg,pb
              mov  mk_readf,#mk_rd32_reg
              mov  mk_writef,#mk_wr32_reg
              ret wcz
mk_setup_ram32
              mov mk_eacache,mk_effaddr
              setword mk_eacache,#@main_ram>>16,#1
              mov  mk_readf,#mk_rd32_ram
              mov  mk_writef,#mk_wr32_ram
              ret wcz


mk_setup_io32
              mov  mk_eacache,mk_effaddr
              zerox mk_eacache,#19
              mov  mk_readf,#mk_rd32_io
              mov  mk_writef,#mk_wr32_io
              ret wcz
mk_setup_imm32
              call #mk_setup_imm16
              mov mk_eatmp0,mk_opword
              call mk_getopf
              rolword mk_eacache,mk_opword,#0
              mov mk_opword,mk_eatmp0
              ret wcz


mk_nibble_4   ' AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
              mov pb,mk_opword ' set this up
              testb mk_opword,#8 wc
        if_c  jmp #.lea_chk  ' got LEA or CHK
              testb mk_opword,#11 wc
        if_nc jmp #.negop_or_srmove ' got NEGX/CLR/NEG/NOT or SR move
              testb mk_opword,#9 wc
        if_c  jmp #.complex ' got one of.. those..
              testb mk_opword,#7 wc
        if_c  jmp #.movem_ext   ' got MOVEM/EXT
              testb mk_opword,#6 wc
        if_nc jmp #mk_hub_nbcd  ' got NBCD
              ' must be SWAP/PEA
              test mk_opword,#%110_000 wz
        if_z  jmp #.swap
              ' ok, PEA
              call #mk_compute_ea ' mk_opword already in PB
              mov mk_memvalue,mk_effaddr
              sub mk_a7,#4
              mov mk_effaddr,mk_a7
              call #mk_setup_ea32
              jmp mk_writef

.complex
              testb mk_opword,#10 wc
        if_nc jmp #mk_hub_tst_tas
              testb mk_opword,#7 wc
        if_c  jmp #.jmp_jsr
              testb mk_opword,#5 wc
        if_nc jmp #mk_hub_link_trap
              testb mk_opword,#4 wc
        if_nc jmp #mk_hub_moveusp
              mov mk_optmp0,mk_opword
              and mk_optmp0,#7
              altd mk_optmp0,#mk_flowop_impl_tbl
              jmp 0-0

.jmp_jsr
              call #mk_compute_ea
              mov mk_branchdisplace,mk_effaddr
              sub mk_branchdisplace,mk_virtualpc
              testb mk_opword,#6 wc ' if NC, got JSR
        if_c  jmp #mk_dobranch
              jmp #mk_call


.swap
              and mk_opword,#15
              altd mk_opword,#mk_d0
              movbyts 0-0,#%%1032
              altd mk_opword,#mk_d0
              shl 0-0,#0 wcz
              bitc mk_sr,#MK_NEG_BIT
              bitz mk_sr,#MK_ZERO_BIT
        _ret_ andn mk_sr,#MK_OVER_MASK|MK_CARRY_MASK


.lea_chk
              testb mk_opword,#6 wc
        if_nc jmp #mk_hub_chk ' got CHK
              ' do LEA
              call #mk_compute_ea ' mk_opword already in PB
              setnib mk_opword,#1,#3
              alti mk_opword,#%000_100_000
        _ret_ mov 0-0,mk_effaddr

.movem_ext
              ' An mode here is technically illegal. We just treat it as extend.
              test mk_opword,#%110_000 wz
        if_nz jmp #mk_hub_movem
              testb mk_opword,#6 wc
        if_nc call #mk_setup_operand16
        if_c  call #mk_setup_operand32
              call mk_readf
        if_nc signx mk_memvalue,#7 wcz
        if_c  signx mk_memvalue,#15 wcz
              bitc mk_sr,#MK_NEG_BIT
              bitz mk_sr,#MK_ZERO_BIT
              andn mk_sr,#MK_OVER_MASK|MK_CARRY_MASK
              jmp mk_writef

.negop_or_srmove
              test mk_opword,#%11_000_000 wcz
        if_00 jmp #mk_hub_srmove ' is move from/to SR/CCR
              call #mk_setup_operand_auto ' mk_opword already in PB
              call mk_readf
              shl mk_memvalue,mk_shiftit
              testb mk_opword,#9 wz
        if_z  jmp #.clr_not ' got CLR or NOT
              ' ok, must be NEG/NEGX
              testb mk_opword,#10 wc
        if_nc jmp #mk_hub_negx
              ' got NEG
              neg mk_memvalue wcz
              bitc mk_sr,#MK_NEG_BIT
              bitz mk_sr,#MK_ZERO_BIT
              muxnz mk_sr,#MK_EXT_MASK|MK_CARRY_MASK
              cmp mk_memvalue,mk_bit31 wz
              bitz mk_sr,#MK_OVER_BIT
              sar mk_memvalue,mk_shiftit
              jmp mk_writef

.clr_not
              testbn mk_opword,#10 wz ' Z set if CLR
        if_z  mov mk_memvalue,#0 wc
        if_nz not mk_memvalue wc
              bitc mk_sr,#MK_NEG_BIT
              andn mk_sr,#MK_CARRY_MASK|MK_OVER_MASK
              shr mk_memvalue,mk_shiftit wz
              bitz mk_sr,#MK_ZERO_BIT
              jmp mk_writef






mk_nibble_C   ' MULx/AND/EXG/ABCD
              test mk_opword,#%11_000_000 wcz
        if_00 jmp #mk_hub_mul ' MULU/MULS
              test mk_opword,#%110_000 wz
              testb mk_opword,#8 andz
        if_nz setr mk_thelogicop,#%0101000_01 ' P2 AND WZ opcode
        if_nz jmp #mk_multilogic ' AND
              test mk_opword,#%11_000_000 wz
        if_z  jmp #mk_hub_abcd
              jmp #mk_hub_exg

mk_nibble_8   ' DIVx/OR/SBCD
              test mk_opword,#%11_000_000 wcz
        if_00 jmp #mk_hub_div ' DIVU/DIVS
              test mk_opword,#%110_000 wz
              testb mk_opword,#8 andz
        if_nz setr mk_thelogicop,#%0101010_01 ' P2 OR WZ opcode
        if_nz jmp #mk_multilogic ' OR
              'test mk_opword,#%11_000_000 wz
              jmp #mk_hub_sbcd

mk_nibble_B   ' CMP (M/A)
              ' check for CMPA
              test mk_opword,#%11_000_000 wcz
        if_00 jmp #mk_cmpa
              ' check for CMP
              testb mk_opword,#8 wc
        if_nc jmp #mk_cmp
              ' check for CMPM
              test mk_opword,#%110_000 wz
              testb mk_opword,#3 andz
        if_z  jmp #mk_hub_cmpm
              ' Ok, is EOR
              setr mk_thelogicop,#%0101011_01 ' P2 XOR WZ opcode
              jmp #mk_multilogic ' XOR


mk_dbcc       ' DBcc
              ' compute destination first...
              call #mk_getopimm16
              signx mk_optmp1,#15
              sub mk_optmp1,#2
              mov mk_branchdisplace,mk_optmp1
              ' check condition
              getnib pb,mk_opword,#2
              shr pb,#1 wc
              altd pb,#mk_condition_truth_table
              testb 0-0,mk_sr xorc
        if_c  ret ' terminated...
              and mk_opword,#7
              alts mk_opword,#mk_d0
              getword mk_optmp0,0-0,#0
              sub mk_optmp0,#1 wc
              altd mk_opword,#mk_d0
              setword 0-0,mk_optmp0,#0
        if_nc jmp #mk_dobranch
              ret

mk_get_second_reg
              mov pb,mk_opword
              shr pb,#9
              and pb,#7
              alts pb,#mk_d0
        _ret_ mov mk_optmp1,0-0

mk_getopimm_auto
              testb pb,#6 wc
        if_c  jmp #mk_getopimm16
              testb pb,#7 wc
        if_c  jmp #mk_getopimm32
              ' fall through!
mk_getopimm8
              mov mk_optmp0,mk_opword
              call mk_getopf
              getbyte mk_optmp1,mk_opword,#0
        _ret_ mov mk_opword,mk_optmp0
mk_getopimm16
              mov mk_optmp0,mk_opword
              call mk_getopf
              mov mk_optmp1,mk_opword
        _ret_ mov mk_opword,mk_optmp0
mk_getopimm32
              mov mk_optmp0,mk_opword
              call mk_getopf
              mov mk_optmp1,mk_opword
              call mk_getopf
              rolword mk_optmp1,mk_opword,#0
        _ret_ mov mk_opword,mk_optmp0



mk_call
              ' Push return address on stack
              sub mk_a7,#4
              mov mk_effaddr,mk_a7
              call #mk_setup_ea32
              mov mk_memvalue,mk_virtualpc
              call mk_writef
              'debug("SP after call: ",uhex_long(mk_a7),uhex_long(mk_virtualpc),shex_long(mk_branchdisplace))
              jmp #mk_dobranch

mk_nibble_6   ' branches
              ' compute destination
              mov mk_optmp1,mk_opword
              signx mk_optmp1,#7 wz
        if_z  call #mk_getopimm16
              signx mk_optmp1,#15
        if_z  sub mk_optmp1,#2
              mov mk_branchdisplace,mk_optmp1
              ' check condition
              getnib pb,mk_opword,#2
              shr pb,#1 wcz
        if_c_and_z jmp #mk_call
              altd pb,#mk_condition_truth_table
              testb 0-0,mk_sr xorc
        if_nc ret
              ' fall through
mk_dobranch
              'debug(uhex_long(mk_virtualpc),shex_long(mk_branchdisplace))
              'mov mk_optmp0,mk_virtualpc '' <--- DELETE THIS WHEN DONE DEBUGGING
              add mk_virtualpc,mk_branchdisplace
              {
              'cmp mk_virtualpc,##$17E6 wz
        'if_e  jmp #.sussy_wussy
              cmp mk_virtualpc,#$1FF wcz
        if_be jmp #.sussy_wussy
              cmps mk_branchdisplace,##$3FFFFF wc
        if_ae jmp #.sussy_wussy
              cmps mk_branchdisplace,##-$3FFFFF wc
        if_ae jmp #.not_a_sussy_baka
.sussy_wussy
              debug("Sussy branch from ",uhex_long_(mk_optmp0)," to ",uhex_long_(mk_virtualpc),uhex_long(mk_a4,mk_a6,mk_d3),uhex_long_array(#@main_ram+$1510,#1))
.not_a_sussy_baka '}
              'debug("branching ",shex(mk_branchdisplace)," to ",uhex_long(mk_virtualpc))
              testb mk_virtualpc,#0 wc
        if_c  jmp #mk_address_error_debug ' TODO: maybe make AE function code read program in this case?
              tjz ptra,#.notfast ' if que not active, this isn't relevant
              ' see if fast branch within que is ok
              sar mk_branchdisplace,#1
              sub mk_romque_left,mk_branchdisplace
              cmp mk_romque_left,#MK_ROMQUE_SIZE+1 wc ' see below
              'debug("would be ",sdec(mk_romque_left))
              ' C set means that (romque_left>=0 && romque_left <= MK_ROMQUE_SIZE). That is the valid range
              ' (Yes, 0 is valid for our purposes, since that will just correctly refill the que on the next getop call)
        if_nc jmp #.notfast
              shl mk_branchdisplace,#1
              add ptra,mk_branchdisplace
              jmp #mk_nextop
.notfast
              mov mk_romque_left,#0
              mov ptra,#0
              'mov pb,mk_virtualpc
              'zerox pb,#23
              getnib pb,mk_virtualpc,#5
              jmprel pb

              jmp #.progexec
              jmp #.ramexec
              jmp #.portexec
              jmp #mk_address_error_debug
              jmp #mk_address_error_debug
              jmp #mk_address_error_debug
              jmp #mk_address_error_debug
              jmp #mk_address_error_debug
              jmp #mk_address_error_debug
              jmp #mk_address_error_debug
              jmp #mk_address_error_debug
              jmp #mk_address_error_debug
              jmp #.biosexec
              jmp #mk_address_error_debug
              jmp #mk_address_error_debug
              jmp #mk_address_error_debug

.progexec
              mov mk_romque_zerox,#19
              mov mk_romque_base,mk_prog_base
              mov mk_getopf,#mk_getop_rom
              jmp #mk_nextop
.portexec
              mov mk_romque_zerox,#19
              mov mk_romque_base,mk_port_base
              mov mk_getopf,#mk_getop_rom
              jmp #mk_nextop
.biosexec
              mov mk_romque_zerox,#16
              mov mk_romque_base,mk_bios_base
              mov mk_getopf,#mk_getop_rom
              jmp #mk_nextop
.ramexec
              mov mk_getopf,#mk_getop_ram
              jmp #mk_nextop


              '' DEBUG NONSENSE: DELETE WHEN DONE
              {
mk_debug_wrchk8
              cmp mk_eacache,##@main_ram+$1510 wz
        if_ne cmp mk_eacache,##@main_ram+$1511 wz
        if_ne cmp mk_eacache,##@main_ram+$1512 wz
        if_ne cmp mk_eacache,##@main_ram+$1513 wz
        if_ne ret wcz
              debug("wrchk8: ",uhex_byte_(mk_memvalue),uhex_word_(mk_eacache),uhex_long_(mk_virtualpc))
              ret wcz
              '' DEBUG NONSENSE: DELETE WHEN DONE
mk_debug_wrchk16
              cmp mk_eacache,##@main_ram+$1510 wz
        if_ne cmp mk_eacache,##@main_ram+$1512 wz
        if_ne ret wcz
              debug("wrchk16: ",uhex_word_(mk_memvalue),uhex_word_(mk_eacache),uhex_long_(mk_virtualpc))
              ret wcz
              '' DEBUG NONSENSE: DELETE WHEN DONE
mk_debug_wrchk32
              cmp mk_eacache,##@main_ram+$150C wz
        if_ne cmp mk_eacache,##@main_ram+$1510 wz
        'if_ne cmp mk_eacache,##@main_ram+$C642 wz
        'if_ne cmp mk_memvalue,##$9BEA_3228    wz
        if_ne ret wcz
              debug("wrchk32: ",uhex_long_(mk_memvalue),uhex_word_(mk_eacache),uhex_long_(mk_virtualpc),uhex_long(mk_d0),uhex_long(mk_a0))
              ret wcz
'}
              {
mk_debug_wrchk8
              getword mk_memtmp0,mk_a7,#0
              getword mk_memtmp1,mk_eacache,#0
              sub mk_memtmp1,mk_memtmp0
              cmp mk_memtmp1,#16 wc
        if_ae ret wcz
              debug("wrchk8: ",uhex_byte_(mk_memvalue),uhex_word_(mk_a7,mk_eacache),uhex_long_(mk_virtualpc),uhex_long_(mk_a0))
              ret wcz
              '}

              fit 1024


DAT ' MotoKore 68000 hub resident code

              orgh

mk_ea_predec
              mov mk_eatmp0,pb
              and mk_eatmp0,#7
              shr pb,#6
              decod pb ' is now step value
              cmp mk_eatmp0,#7 wz ' A7 is a special snowflake...
        if_z  fge pb,#2

              altd mk_eatmp0,#mk_a0
              sub 0-0,pb
              alts mk_eatmp0,#mk_a0
        _ret_ mov mk_effaddr,0-0

mk_ea_postinc
              mov mk_eatmp0,pb
              and mk_eatmp0,#7
              shr pb,#6
              decod pb ' is now step value
              cmp mk_eatmp0,#7 wz ' A7 is a special snowflake...
        if_z  fge pb,#2

              alts mk_eatmp0,#mk_a0
              mov mk_effaddr,0-0
              altd mk_eatmp0,#mk_a0
        _ret_ add 0-0,pb

mk_ea_displace
              and pb,#7
              alts pb,#mk_a0
              mov mk_effaddr,0-0

              mov mk_eatmp1,mk_opword ' backup
              call mk_getopf
              signx mk_opword,#15
              add mk_effaddr,mk_opword
        _ret_ mov mk_opword,mk_eatmp1 ' restore


mk_ea_index
              and pb,#7
              alts pb,#mk_a0
              mov mk_effaddr,0-0
              'debug(if(mk_debug_ctr),"from address register: ",uhex_long_(mk_effaddr))

              mov mk_eatmp1,mk_opword ' backup
              call mk_getopf
              ' handle index reg
              getnib pb,mk_opword,#3
              alts pb,#mk_d0
              mov pb,0-0
              testb mk_opword,#11 wc
        if_nc signx pb,#15
              'debug(if(mk_debug_ctr),"from index register: ",uhex_long_(pb))
              add mk_effaddr,pb
              ' handle displacement
              signx mk_opword,#7
              'debug(if(mk_debug_ctr),"from displacement: ",uhex_long_(mk_opword))
               add mk_effaddr,mk_opword
              'debug(if(mk_debug_ctr),"final: ",uhex_long_(mk_effaddr))
        _ret_ mov mk_opword,mk_eatmp1 ' restore


mk_ea_headache
              mov mk_eatmp1,mk_opword ' backup
              call mk_getopf
              'debug("in mk_ea_headache ",uhex_word(mk_opword))
              testb pb,#0 wz
              testb pb,#1 wc
        if_01 jmp #.longabs
        if_11 jmp #.index
              signx mk_opword,#15 ' absolute short or PC displacement
              mov mk_effaddr,mk_opword
        if_1x add mk_effaddr,mk_virtualpc
        if_1x sub mk_effaddr,#2
        _ret_ mov mk_opword,mk_eatmp1 ' restore

.longabs
              mov  mk_effaddr,mk_opword
              call mk_getopf
              rolword mk_effaddr,mk_opword,#0
        _ret_ mov mk_opword,mk_eatmp1 ' restore

.index
              mov mk_effaddr,mk_virtualpc
              sub mk_effaddr,#2
              ' handle index reg
              getnib pb,mk_opword,#3
              alts pb,#mk_d0
              mov pb,0-0
              testb mk_opword,#11 wc
        if_nc signx pb,#15
              add mk_effaddr,pb
              ' handle displacement
              signx mk_opword,#7
              add mk_effaddr,mk_opword
              'debug("computed address for (d8,PC,Dn) is ",uhex_long(mk_effaddr),uhex_long(mk_virtualpc))
        _ret_ mov mk_opword,mk_eatmp1 ' restore


mk_hub_wr_sr
              ' Status register write escalated
              ' C is still super bit from SR
        if_nc mov pb,#$20 ' privilege violation
        if_nc jmp #mk_hub_trapit
mk_hub_set_sr
              'debug("in mk_hub_set_sr ",uhex_word(mk_sr,mk_memvalue),uhex_long(mk_virtualpc))
              testb mk_sr,#MK_SUPER_BIT wc
              testb mk_memvalue,#MK_SUPER_BIT xorc
              ' switching supervisor/user: swap stack pointers
        if_c  xor mk_a7,mk_othersp
        if_c  xor mk_othersp,mk_a7
        if_c  xor mk_a7,mk_othersp

              ' configure hooks
              and mk_memvalue,##%10100111_00011111
              testb mk_memvalue,#MK_TRACE_BIT wc
        if_c  mov mk_ihook1,##(%1111_1101100_0<<20) + @mk_hub_tracehook ' JMP #\mk_hub_tracehook
        if_c  jmp #.no_irqhooks
              ' check irq level
              getnib pb,mk_memvalue,#2
              cmp pb,#2 wc
        if_ae mov mk_ihook1,#0 ' NOP
        if_b  mov mk_ihook1,##(%1111_1011110_010_000000101<<9)+mk_irq2ptr ' JSE2 mk_irq2ptr
              cmp pb,#1 wc
        if_ae mov mk_ihook2,#0 ' NOP
        if_b  mov mk_ihook2,##(%1111_1011110_010_000000100<<9)+mk_irq1ptr ' JSE1 mk_irq1ptr
.no_irqhooks

              mov mk_sr,mk_memvalue
              ret wcz

mk_hub_irq2
              mov pb,#2
              setse2 #4 ' disable event (set to LUT write trigger) until ACK
              skip #%11
mk_hub_irq1
              setse1 #4 ' disable event (set to LUT write trigger) until ACK
              mov pb,#1
mk_hub_do_irq
              'debug("running IRQ ",udec(pb))
              'debug(uhex_word_array(#@vdp_ram+$FB60,#2))
              'waitx ##10_000_000
              ' get vector
              mov mk_optmp0,pb
              shl mk_optmp0,#2
              add mk_optmp0,mk_vectors_ptr
              add mk_optmp0,#$60
              rdlong mk_branchdisplace,mk_optmp0
              sub mk_branchdisplace,mk_virtualpc
              ' set supervisor mode, unset trace mode and set interrupt priority
              mov mk_optmp2,mk_sr
              mov mk_memvalue,mk_sr
              bith pb,#MK_SUPER_BIT-8
              setbyte mk_memvalue,pb,#1
              call #mk_hub_set_sr
              ' push PC
              sub mk_a7,#4
              mov mk_effaddr,mk_a7
              call #mk_setup_ea32
              mov mk_memvalue,mk_virtualpc
              call mk_writef
              ' push SR
              sub mk_a7,#2
              mov mk_effaddr,mk_a7
              call #mk_setup_ea16
              mov mk_memvalue,mk_optmp2
              call mk_writef
              'waitx ##_CLKFREQ/120
              jmp #mk_dobranch




mk_hub_tracehook
              getnib pb,mk_sr,#2
              cmp pb,#2 wc
        if_b  JSE2 mk_irq2ptr
              cmp pb,#1 wc
        if_b  JSE1 mk_irq1ptr
              mov pb,#$24
              jmp #mk_hub_trapit


mk_nibble_A   ' Line A emulator
              mov pb,#$28
              jmp #mk_hub_trapit

mk_nibble_F   ' Line F emulator
              mov pb,#$2C
              ' fall through
mk_hub_trapit
              debug("handling trap with vector ",uhex_(pb)," @ ",uhex_long(mk_virtualpc))
              ' get vector
              add pb,mk_vectors_ptr
              rdlong mk_branchdisplace,pb
              sub mk_branchdisplace,mk_virtualpc
              ' set supervisor mode, unset trace mode
              mov mk_optmp2,mk_sr
              mov mk_memvalue,mk_sr
              bith mk_memvalue,#MK_SUPER_BIT
              bitl mk_memvalue,#MK_TRACE_BIT
              call #mk_hub_set_sr
              ' push PC
              sub mk_a7,#4
              mov mk_effaddr,mk_a7
              call #mk_setup_ea32
              mov mk_memvalue,mk_virtualpc
              call mk_writef
              ' push SR
              sub mk_a7,#2
              mov mk_effaddr,mk_a7
              call #mk_setup_ea16
              mov mk_memvalue,mk_optmp2
              call mk_writef
              jmp #mk_dobranch

mk_address_error_debug
              'drvh #38
              debug("special edition spicy address error ")
              'jmp #$
mk_address_error ' can basically only happen due to misalignment?
              debug("something something address error ",uhex_long(mk_effaddr),uhex_long(mk_virtualpc),uhex_long(mk_optmp0))
              debug(uhex_long(mk_a0))
              wrlong ##$FF00FF_00,##palette32+4*16*256-4
              jmp #$
              ' get vector
              mov mk_optmp1,mk_vectors_ptr
              add mk_optmp1,#$0C
              rdlong mk_branchdisplace,mk_optmp1
              sub mk_branchdisplace,mk_virtualpc
              mov mk_optmp1,mk_effaddr ' save for later
              ' set supervisor mode, unset trace mode
              mov mk_optmp2,mk_sr
              mov mk_memvalue,mk_sr
              bith mk_memvalue,#MK_SUPER_BIT
              bitl mk_memvalue,#MK_TRACE_BIT
              call #mk_hub_set_sr
              ' push PC
              sub mk_a7,#4
              mov mk_effaddr,mk_a7
              call #mk_setup_ea32
              mov mk_memvalue,mk_virtualpc
              call mk_writef
              ' push SR
              sub mk_a7,#2
              mov mk_effaddr,mk_a7
              call #mk_setup_ea16
              mov mk_memvalue,mk_optmp2
              call mk_writef
              ' push instruction in progress (maybe)
              sub mk_a7,#2
              mov mk_effaddr,mk_a7
              call #mk_setup_ea16
              mov mk_memvalue,mk_opword
              call mk_writef
              ' push erroneous address
              sub mk_a7,#4
              mov mk_effaddr,mk_a7
              call #mk_setup_ea32
              mov mk_memvalue,mk_optmp1
              call mk_writef
              ' push flags
              sub mk_a7,#2
              mov mk_effaddr,mk_a7
              call #mk_setup_ea16
              ' slight problem: we don't know half this shit
              mov mk_memvalue,#%10_001 ' assume it's a data read. It's probably a data read. Isn't it?
              testb mk_optmp2,#MK_SUPER_BIT wc
              bitc mk_memvalue,#2 ' we do know what mode we were in though
              call mk_writef
              jmp #mk_dobranch








mk_hub_stop
              call #mk_getopimm16
              debug("STOP instruction ",uhex_word(mk_opword),uhex_word(mk_optmp1)," encountered")
              'debug(uhex_word_array(#vdp_ram+$C418,#16))
               mov mk_memvalue,mk_optmp1
               call #mk_wr_sr
.waitloop
              '' TODO: re-enable interrupt support
              {
              pollatn wc
        if_c  rdbyte pb,#atn_command wc
        if_c  jmp #mk_hub_hotreset
              }
              getnib pb,mk_sr,#2
              cmp pb,#2 wc
        if_b  JSE2 mk_irq2ptr
              cmp pb,#1 wc
        if_b  JSE1 mk_irq1ptr
              jmp #.waitloop
              debug("jooo wtf")

mk_hub_reset
              debug("RESET instruction ",uhex_word(mk_opword)," encountered")
              jmp #$

mk_hub_nop
              cmp mk_opword,##$4E71 wz
        if_z  ret
              debug("weird NOP ? ",uhex_word(mk_opword),uhex_long(mk_virtualpc))
              ret



mk_hub_rte
              testb mk_sr,#MK_SUPER_BIT wc
        if_nc mov pb,#$20 ' privilege violation
        if_nc jmp #mk_hub_trapit
              mov mk_effaddr,mk_a7
              call #mk_setup_ea16
              call mk_readf
              mov mk_optmp2,mk_memvalue ' only write SR after we're done popping
              add mk_a7,#2
              mov mk_effaddr,mk_a7
              call #mk_setup_ea32
              call mk_readf
              mov mk_branchdisplace,mk_memvalue
              sub mk_branchdisplace,mk_virtualpc
              add mk_a7,#4
              'debug("RTE from ",uhex_long_(mk_virtualpc)," to ",uhex_long(mk_memvalue))
              mov mk_memvalue,mk_optmp2 ' only write SR after we're done popping
              call #mk_wr_sr
              jmp #mk_dobranch

mk_hub_rtr
              mov mk_effaddr,mk_a7
              call #mk_setup_ea16
              call mk_readf
              call #mk_wr_ccr
              add mk_a7,#2
              ' fall through
mk_hub_rts
              mov mk_effaddr,mk_a7
              call #mk_setup_ea32
              call mk_readf
              'debug("SP before RTS: ",uhex_long(mk_a7),uhex_long(mk_memvalue),uhex_long(mk_virtualpc))
              mov mk_branchdisplace,mk_memvalue
              sub mk_branchdisplace,mk_virtualpc
              add mk_a7,#4
              jmp #mk_dobranch


mk_hub_trapv
              testb mk_sr,#MK_OVER_BIT wc
        if_nc ret
              mov pb,#$1C
              jmp #mk_hub_trapit

mk_hub_moveusp
              testb mk_sr,#MK_SUPER_BIT wc
        if_nc mov pb,#$20
        if_nc jmp #mk_hub_trapit ' TODO: proper non-supervisor trap
              mov pb,mk_opword
              and pb,#7
              testb mk_opword,#3 wc ' if C, read USP, if NC, write USP
              debug("in mk_hub_moveusp ",uhex_word(mk_opword),udec(pb),uhex_long(mk_othersp),uhex_long(mk_nibble_impl_tbl+3),uhex_long(inb))
        if_c  altd pb,#mk_a0
        if_c  mov 0-0,mk_othersp
        if_nc alts pb,#mk_a0
        if_nc mov mk_othersp,0-0
              debug("in mk_hub_moveusp again ",uhex_word(mk_opword),udec(pb),uhex_long(mk_othersp),uhex_long(mk_nibble_impl_tbl+3))
              ret



mk_hub_tst_tas
              getbyte mk_optmp0,mk_opword,#0
              cmp mk_optmp0,#%11_111_100 wz
        if_z  jmp #mk_illegal
              test mk_opword,#%11_000_000 wcz
        if_00 andn pb,#%11_000_000 ' convert TAS to TST.B (Note: if_00 here really means ""if_11"" (not zero and even parity))
              call #mk_setup_operand_auto
              call mk_readf
              'debug("in TST/TAS with ",uhex_long(mk_virtualpc),uhex_word(mk_opword),uhex(mk_memvalue),uhex(mk_shiftit),uhex(mk_d0))
              shl mk_memvalue,mk_shiftit wz
              testb mk_memvalue,#31 wc
              bitc mk_sr,#MK_NEG_BIT
              bitz mk_sr,#MK_ZERO_BIT
              andn mk_sr,#MK_OVER_MASK|MK_CARRY_MASK
              'debug("SR after",ubin_word(mk_sr))
              test mk_opword,#%11_000_000 wcz
        if_c_or_z ret ' not TAS
              test mk_opword,#%00_111_000 wz
        if_nz ret ' not register TAS (memory TAS is broken due to buggy SEGA bus logic)
              shr mk_memvalue,#24
              or mk_memvalue,#$80
              jmp mk_writef

mk_hub_link_trap
              testb mk_opword,#4 wc
        if_nc jmp #.trap
              testb mk_opword,#3 wc
        if_c  jmp #.unlk
              ' okay, LINK
              sub mk_a7,#4
              mov mk_effaddr,mk_a7
              mov mk_optmp0,mk_opword
              and mk_optmp0,#7
              call #mk_setup_ea32
              alts mk_optmp0,#mk_a0
              mov mk_memvalue,0-0
              call mk_writef
              altd mk_optmp0,#mk_a0
              mov 0-0,mk_a7
              call #mk_getopimm16
              signx mk_optmp1,#15
        _ret_ add mk_a7,mk_optmp1


.unlk         ' UNLK
              mov mk_optmp0,mk_opword
              and mk_optmp0,#7
              alts mk_optmp0,#mk_a0
              mov mk_a7,0-0
              mov mk_effaddr,mk_a7
              call #mk_setup_ea32
              call mk_readf
              altd mk_optmp0,#mk_a0
              mov 0-0,mk_memvalue
        _ret_ add mk_a7,#4


.trap
              getnib pb,mk_opword,#0
              shl pb,#2
              add pb,#$80
              jmp #mk_hub_trapit


mk_nibble_7 ' MOVEQ
              mov pb,mk_opword
              and pb,mk_dreg_mask
              signx mk_opword,#7 wcz
              bitc mk_sr,#MK_NEG_BIT
              bitz mk_sr,#MK_ZERO_BIT
              andn mk_sr,#MK_OVER_MASK|MK_CARRY_MASK
              alti pb,#%000_100_000
.moveop _ret_ mov mk_d0,mk_opword


mk_hub_movem  ' MOVEM
              'debug("in mk_hub_movem ",uhex_long(mk_a0))
              call #mk_getopimm16
              testb mk_opword,#10 wc
        if_c  neg mk_optmp2,#1
        if_c  jmp #.movem_do_read
              'debug(ubin_word(mk_opword))
              test mk_opword,#%011_000 wz
        if_z  mov mk_optmp2,#mk_a7
        if_z  jmp #.movem_do_predec_write
              mov mk_optmp2,#0
              call #mk_compute_ea
              jmp #.movem_write

              ' MOVEM normal write
.writeloop
              testb mk_opword,#6 wc ' long/word ?
        if_c  call #mk_setup_ea32
        if_nc call #mk_setup_ea16
              call mk_writef
        if_c  add mk_effaddr,#4
        if_nc add mk_effaddr,#2
.movem_write
              'debug("at .movem_write ",uhex_long(mk_optmp2),uhex_long(mk_effaddr),ubin_word(mk_optmp1))
              alti mk_optmp2,#%000_000_111 ' increment register ptr
              mov mk_memvalue,0-0
              'debug("got value ",uhex_long(mk_memvalue),uhex_long(mk_optmp2))
              shr mk_optmp1,#1 wcz
        if_c  jmp #.writeloop
        if_nc_and_nz jmp #.movem_write
              ret



              ' MOVEM predec write
.movem_do_predec_write
              mov pb,mk_opword
              and pb,#7
              alts pb,#mk_a0
              mov mk_effaddr,0-0
              jmp #.movem_predec_write

.predec_write_loop
              testb mk_opword,#6 wc ' long/word ?
        if_c  sub mk_effaddr,#4
        if_nc sub mk_effaddr,#2
        if_c  call #mk_setup_ea32
        if_nc call #mk_setup_ea16
              call mk_writef
.movem_predec_write
              'debug("at .movem_predec_write ",uhex_long(mk_optmp2),uhex_long(mk_effaddr),ubin_word(mk_optmp1),uhex_word(mk_opword))
              alti mk_optmp2,#%000_000_110 ' decrement register ptr
              mov mk_memvalue,0-0
              shr mk_optmp1,#1 wcz
        if_c  jmp #.predec_write_loop
        if_nc_and_nz jmp #.movem_predec_write
              ' done.
              and mk_opword,#7
              altd mk_opword,#mk_a0
        _ret_ mov 0-0,mk_effaddr

              ' MOVEM read
.movem_do_read
              call #mk_compute_ea
              jmp #.movem_read

.readloop

              testb mk_opword,#6 wc ' long/word ?
        if_c  call #mk_setup_ea32
        if_nc call #mk_setup_ea16
              call mk_readf
        if_c  altd mk_optmp2,#mk_d0
        if_c  mov 0-0,mk_memvalue
        if_c  add mk_effaddr,#4
        if_nc altd mk_optmp2,#mk_d0
        if_nc setword 0-0,mk_memvalue,#0
        if_nc add mk_effaddr,#2
.movem_read
              'debug("at .movem_read",uhex_long(mk_optmp2),uhex_long(mk_effaddr),ubin_word(mk_optmp1),uhex_word(mk_opword))
              add mk_optmp2,#1
              shr mk_optmp1,#1 wcz
        if_c  jmp #.readloop
        if_nc_and_nz jmp #.movem_read
              ' if empty
              mov pb,mk_opword
              and pb,#%111_000
              cmp pb,#%011_000 wz ' is postinc mode?
        if_nz ret
              and mk_opword,#7
              altd mk_opword,#mk_a0
        _ret_ mov 0-0,mk_effaddr




mk_hub_movep  ' MOVEP
              debug("in mk_hub_movep")
              ' compute address
              call #mk_getopimm16
              signx mk_optmp1,#15
              mov mk_effaddr,mk_optmp1
              getnib pb,mk_opword,#0 ' will be %1xxx
              alts pb,#mk_d0
              add mk_effaddr,0-0

              testb mk_opword,#7 wc
        if_c  jmp #.movep_write

              call #mk_setup_ea8
              call mk_readf
              rolbyte mk_optmp2,mk_memvalue,#0
              add mk_effaddr,#2
              call #mk_setup_ea8
              call mk_readf
              rolbyte mk_optmp2,mk_memvalue,#0
              testb mk_opword,#6 wc
        if_nc mov mk_shiftit,#16
        if_nc jmp #.read_done
              mov mk_shiftit,#0
              add mk_effaddr,#2
              call #mk_setup_ea8
              call mk_readf
              rolbyte mk_optmp2,mk_memvalue,#0
              add mk_effaddr,#2
              call #mk_setup_ea8
              call mk_readf
              rolbyte mk_optmp2,mk_memvalue,#0
.read_done
              mov mk_memvalue,mk_optmp2
              jmp #mk_write_second_reg


.movep_write
              call #mk_get_second_reg
              testb mk_opword,#6 wc
        if_nc shl mk_optmp1,#16
              call #mk_setup_ea8
              getbyte mk_memvalue,mk_optmp1,#3
              call mk_writef
              add mk_effaddr,#2
              call #mk_setup_ea8
              getbyte mk_memvalue,mk_optmp1,#2
              call mk_writef
              testb mk_opword,#6 wc
        if_nc ret
              add mk_effaddr,#2
              call #mk_setup_ea8
              getbyte mk_memvalue,mk_optmp1,#1
              call mk_writef
              add mk_effaddr,#2
              call #mk_setup_ea8
              getbyte mk_memvalue,mk_optmp1,#0
              jmp mk_writef



mk_hub_mul    ' MULU/MULS
              mov pb,mk_opword
              call #mk_setup_operand16
              call mk_readf
              mov pb,mk_opword
              and pb,mk_dreg_mask
              testb mk_opword,#8 wc ' set c if signed
        if_nc alti pb,#%000_100_000
        if_nc mul 0-0,mk_memvalue wz
        if_c  alti pb,#%000_100_000
        if_c  muls 0-0,mk_memvalue wz
              bitz mk_sr,#MK_ZERO_BIT
              alti pb,#%000_100_000
              testb 0-0,#31 wz
              bitz mk_sr,#MK_NEG_BIT
        _ret_ andn mk_sr,#MK_CARRY_MASK|MK_OVER_MASK

mk_hub_div    ' DIVU/DIVS
              mov pb,mk_opword
              call #mk_setup_operand16
              call mk_readf ' get divider
              mov pb,mk_opword
              shr pb,#9
              and pb,#7
              alts pb,#mk_d0
              mov mk_optmp0,0-0 ' get divisor
              tjz mk_memvalue,#.by_zero
              mov mk_optmp1,#0 ' bit 0 holds appropriate result sign
              testb mk_opword,#8 wz ' set z if signed
        if_z  signx mk_memvalue,#15
        if_z  abs mk_memvalue wc
        if_z_and_c bitnot mk_optmp1,#0
        if_z  abs mk_optmp0 wc
        if_z_and_c bitnot mk_optmp1,#0
              qdiv mk_optmp0,mk_memvalue
              bitl mk_sr,#MK_CARRY_BIT
              getqx mk_memvalue    ' quotient
              getqy mk_optmp0      ' remainder
              ' Apply sign
              testb mk_optmp1,#0 wc
              negc mk_memvalue
              negc mk_optmp0
              testb mk_memvalue,#15 wc
              bitc mk_sr,#MK_NEG_BIT
              ' Check overflow
              mov mk_optmp1,mk_memvalue
              testb mk_opword,#8 wz ' set z if signed
        if_z  signx mk_memvalue,#15
        if_nz zerox mk_memvalue,#15
              cmp mk_optmp1,mk_memvalue wz
              bitnz mk_sr,#MK_OVER_BIT
        if_nz bith mk_sr,#MK_NEG_BIT ' Undocumented flag
        if_nz ret
              ' set Z flag (not set on overflow?)
              cmp mk_memvalue,#0 wz
              bitz mk_sr,#MK_ZERO_BIT
              ' write back
              setword mk_memvalue,mk_optmp0,#1
              altd pb,#mk_d0
        _ret_ mov 0-0,mk_memvalue

.by_zero
              mov pb,#$14
              ' Strange flags...
              andn mk_sr,#MK_CARRY_MASK|MK_OVER_MASK|MK_NEG_MASK
              testb mk_opword,#8 wc ' set c if signed
        if_c  bith mk_sr,#MK_ZERO_BIT
        if_c  jmp #mk_hub_trapit
              shr mk_optmp0,#16
              cmps mk_optmp0,#0 wcz
              bitz mk_sr,#MK_ZERO_BIT
              bitc mk_sr,#MK_NEG_BIT
              jmp #mk_hub_trapit


mk_hub_srmove
              call #mk_setup_operand16
              testb mk_opword,#10 wc ' FROM (NC) or TO (C) SR
        if_nc push mk_writef
        if_nc jmp #mk_rd_sr
              testb mk_opword,#9 wz ' if to SR, to whole SR (Z) or CCR only (NZ)
        if_z  push #mk_wr_sr
        if_nz push #mk_wr_ccr
              jmp mk_readf



mk_hub_exg
              ' okay got EXG
              ' encoding is a bit stupid, see manual
              mov pb,mk_opword
              and pb,#7 ' register Y
              mov pa,mk_opword
              shr pa,#9
              and pa,#7 ' register X
              testb mk_opword,#3 wc
              testb mk_opword,#7 wz
        if_c  add pb,#8
        if_c_and_nz add pa,#8
              alts pb,#mk_d0
              mov mk_optmp0,0-0
              alts pa,#mk_d0
              mov mk_optmp1,0-0
              altd pb,#mk_d0
              mov 0-0,mk_optmp1
              altd pa,#mk_d0
        _ret_ mov 0-0,mk_optmp0


mk_hub_abcd   ' ABCD
              ' isolate register nos
              mov mk_optmp0,mk_opword
              and mk_optmp0,#7 ' source
              mov mk_optmp2,mk_opword
              shr mk_optmp2,#9
              and mk_optmp2,#7 ' destination
              ' check for -(An),-(An) mode
              testb mk_opword,#3 wc
        if_c  jmp #.memmode
              alts mk_optmp0,#mk_d0
              getbyte mk_optmp1,0-0,#0
              alts mk_optmp2,#mk_d0
              getbyte mk_memvalue,0-0,#0
.doit
              ' See: https://github.com/flamewing/68k-bcd-verifier/blob/master/bcd-emul.cc#L52
              ' compute ss
              testb mk_sr,#MK_EXT_BIT wc
              mov mk_optmp0,mk_memvalue
              addx mk_optmp0,mk_optmp1
              ' compute bc
              mov mk_optmp2,mk_memvalue
              and mk_optmp2,mk_optmp1
              andn mk_memvalue,mk_optmp0 ' note: don't need the original operands anymore
              or mk_optmp2,mk_memvalue
              andn mk_optmp1,mk_optmp0 ' note: ^^
              or mk_optmp2,mk_optmp1
              and mk_optmp2,#$88
              ' compute dc
              mov mk_memvalue,mk_optmp0
              add mk_memvalue,#$66
              xor mk_memvalue,mk_optmp0
              and mk_memvalue,#$110
              shr mk_memvalue,#1
              ' compute corf
              or mk_memvalue,mk_optmp2
              sca mk_memvalue,##$4000 ' equivalent to >> 2
              sub mk_memvalue,0-0
              ' compute result
              add mk_memvalue,mk_optmp0
              ' write to register if needed
              testb mk_opword,#3 wc
        if_nc and mk_opword,mk_dreg_mask ' don't need opword anymore
        if_nc alti mk_opword,#%000_100_000
        if_nc setbyte 0-0,mk_memvalue,#0
              ' compute carry
              testb mk_optmp0,#7 wc
              testbn mk_memvalue,#7 andc
              testb mk_optmp2,#7 orc
              muxc mk_sr,#MK_CARRY_MASK|MK_EXT_MASK
              ' compute overflow
              testbn mk_optmp0,#7 wc
              testb mk_memvalue,#7 andc
              bitc mk_sr,#MK_OVER_BIT
              ' compute zero flag
              test mk_memvalue,#255 wz
        if_nz bitl mk_sr,#MK_ZERO_BIT
              ' compute neg flag
              testb mk_memvalue,#7 wc
        _ret_ bitc mk_sr,#MK_NEG_BIT
              ' returns either to nextop or mk_writef
.memmode
              altd mk_optmp0,#mk_a0
              sub  0-0,#1
              alts mk_optmp0,#mk_a0
              mov  mk_effaddr,0-0
              call #mk_setup_ea8
              call mk_readf
              mov mk_optmp1,mk_memvalue
              altd mk_optmp2,#mk_a0
              sub  0-0,#1
              alts mk_optmp2,#mk_a0
              mov  mk_effaddr,0-0
              call #mk_setup_ea8
              ' - jmp into mk_readf
              ' - returns into .doit
              ' - returns into mk_writef
              push mk_writef
              loc pb,#.doit
              push pb
              jmp mk_readf


mk_hub_sbcd
              ' isolate register nos
              mov mk_optmp0,mk_opword
              and mk_optmp0,#7 ' source
              mov mk_optmp2,mk_opword
              shr mk_optmp2,#9
              and mk_optmp2,#7 ' destination
              ' check for -(An),-(An) mode
              testb mk_opword,#3 wc
        if_c  jmp #.memmode
              alts mk_optmp0,#mk_d0
              getbyte mk_optmp1,0-0,#0
              alts mk_optmp2,#mk_d0
              getbyte mk_memvalue,0-0,#0
.doit
              ' See: https://github.com/flamewing/68k-bcd-verifier/blob/master/bcd-emul.cc#L80
              ' compute dd
              testb mk_sr,#MK_EXT_BIT wc
              mov mk_optmp0,mk_memvalue
              subx mk_optmp0,mk_optmp1
              ' compute bc
              not mk_optmp2,mk_memvalue
              and mk_optmp2,mk_optmp1
              not  mk_memvalue ' note: don't need the original operands anymore
              and mk_memvalue,mk_optmp0
              or mk_optmp2,mk_memvalue
              and mk_optmp1,mk_optmp0 ' note: ^^
              or mk_optmp2,mk_optmp1
              and mk_optmp2,#$88
              ' compute corf
              mov mk_memvalue,mk_optmp2
              sca mk_memvalue,##$4000 ' equivalent to >> 2
              sub mk_memvalue,0-0
              ' compute result
              subr mk_memvalue,mk_optmp0
              ' write to register if needed
              testb mk_opword,#3 wc
        if_nc and mk_opword,mk_dreg_mask ' don't need opword anymore
        if_nc alti mk_opword,#%000_100_000
        if_nc setbyte 0-0,mk_memvalue,#0
              ' compute carry
              testbn mk_optmp0,#7 wc
              testb mk_memvalue,#7 andc
              testb mk_optmp2,#7 orc
              muxc mk_sr,#MK_CARRY_MASK|MK_EXT_MASK
              ' compute overflow
              testb mk_optmp0,#7 wc
              testbn mk_memvalue,#7 andc
              bitc mk_sr,#MK_OVER_BIT
              ' compute zero flag
              test mk_memvalue,#255 wz
        if_nz bitl mk_sr,#MK_ZERO_BIT
              ' compute neg flag
              testb mk_memvalue,#7 wc
        _ret_ bitc mk_sr,#MK_NEG_BIT
              ' returns either to nextop or mk_writef
.memmode
              altd mk_optmp0,#mk_a0
              sub  0-0,#1
              alts mk_optmp0,#mk_a0
              mov  mk_effaddr,0-0
              call #mk_setup_ea8
              call mk_readf
              mov mk_optmp1,mk_memvalue
              altd mk_optmp2,#mk_a0
              sub  0-0,#1
              alts mk_optmp2,#mk_a0
              mov  mk_effaddr,0-0
              call #mk_setup_ea8
              ' - jmp into mk_readf
              ' - returns into .doit
              ' - returns into mk_writef
              push mk_writef
              loc pb,#.doit
              push pb
              jmp mk_readf




mk_hub_nbcd
              'debug ("in NBCD with ",uhex(mk_opword))
              call #mk_setup_operand8 ' opword still in PB!
              call mk_readf
              ' See: https://github.com/flamewing/68k-bcd-verifier/blob/master/bcd-emul.cc#L104
              ' compute dd
              neg mk_optmp0,mk_memvalue
              testb mk_sr,#MK_EXT_BIT wc
        if_c  sub mk_optmp0,#1
              ' compute bc
              mov mk_optmp2,mk_memvalue
              or mk_optmp2,mk_optmp0
              and mk_optmp2,#$88
              ' compute corf
              mov mk_memvalue,mk_optmp2
              sca mk_memvalue,##$4000 ' equivalent to >> 2
              sub mk_memvalue,0-0
              ' compute result
              subr mk_memvalue,mk_optmp0
              ' compute carry
              testbn mk_optmp0,#7 wc
              testb mk_memvalue,#7 andc
              testb mk_optmp2,#7 orc
              muxc mk_sr,#MK_CARRY_MASK|MK_EXT_MASK
              ' compute overflow
              testb mk_optmp0,#7 wc
              testbn mk_memvalue,#7 andc
              bitc mk_sr,#MK_OVER_BIT
              ' compute zero flag
              test mk_memvalue,#255 wz
        if_nz bitl mk_sr,#MK_ZERO_BIT
              ' compute neg flag
              testb mk_memvalue,#7 wc
              bitc mk_sr,#MK_NEG_BIT
              jmp mk_writef



mk_hub_addsubx
              'debug("in mk_hub_addsubx")
              ' isolate register nos
              mov mk_optmp0,mk_opword
              and mk_optmp0,#7 ' source
              mov mk_optmp2,mk_opword
              shr mk_optmp2,#9
              and mk_optmp2,#7 ' destination
              ' check for -(An),-(An) mode
              testb mk_opword,#3 wc
        if_c  jmp #.memmode
              ' read source
              mov pb,mk_opword ' operand is already register
              call #mk_setup_operand_auto
              call mk_readf
              mov mk_optmp1,mk_memvalue
              ' read destination
              mov pb,mk_opword
              getnib pb,mk_opword,#2
              shr pb,#1
              setq #%11_000_000
              muxq pb,mk_opword
              call #mk_setup_operand_auto
              call mk_readf
              testb mk_opword,#14 wc ' C = ADD,NC = SUB ?
        if_nc jmp #.do_sub
              ' fall  through
.do_add
              'debug("in .do_add with ",uhex(mk_memvalue),uhex(mk_optmp1),udec(mk_shiftit))
              testb mk_sr,#MK_EXT_BIT wc
              ' must be rcl for correct ripple carry
              rcl mk_memvalue,mk_shiftit
              rcl mk_optmp1,mk_shiftit
              ' generate stupid overflow flag
              mov mk_optmp0,mk_optmp1
              addsx mk_optmp0,mk_memvalue wc
              testb mk_optmp0,#31 xorc
              bitc mk_sr,#MK_OVER_BIT
              ' do actual add
              testb mk_sr,#MK_EXT_BIT wc
              addx mk_memvalue,mk_optmp1 wcz
              muxc mk_sr,#MK_CARRY_MASK|MK_EXT_MASK
              testb mk_optmp0,#31 wc
              bitc mk_sr,#MK_NEG_BIT
              sar mk_memvalue,mk_shiftit wz
        if_nz bitl mk_sr,#MK_ZERO_BIT
              'debug("got result ",uhex(mk_memvalue))
              jmp mk_writef

.do_sub
              shl mk_memvalue,mk_shiftit
              shl mk_optmp1,mk_shiftit
              ' generate stupid overflow flag
              mov mk_optmp0,mk_memvalue
              testb mk_sr,#MK_EXT_BIT wc
              subsx mk_optmp0,mk_optmp1 wc
              testb mk_optmp0,#31 xorc
              bitc mk_sr,#MK_OVER_BIT
              ' do actual sub
              testb mk_sr,#MK_EXT_BIT wc
              subx mk_memvalue,mk_optmp1 wcz
              muxc mk_sr,#MK_CARRY_MASK|MK_EXT_MASK
              testb mk_optmp0,#31 wc
              bitc mk_sr,#MK_NEG_BIT
              sar mk_memvalue,mk_shiftit wz
        if_nz bitl mk_sr,#MK_ZERO_BIT
              jmp mk_writef

.memmode
              ' read source
              mov pb,mk_opword
              xor pb,#%101_000 ' turn into -(An) (is %001_xxx to begin with)
              call #mk_setup_operand_auto
              call mk_readf
              mov mk_optmp1,mk_memvalue
              ' read destination
              mov pb,mk_opword
              getnib pb,mk_opword,#2
              shr pb,#1
              setq #%11_000_000
              muxq pb,mk_opword
              or pb,#%100_000 ' turn into -(An) (is %001_xxx to begin with)
              call #mk_setup_operand_auto
              testb mk_opword,#14 wc ' C = ADD,NC = SUB ?
        if_c  loc pb,#.do_add
        if_nc loc pb,#.do_sub
              push pb
              jmp mk_readf



mk_hub_negx
              '' NOTE: operand is already set up and shifted
              mov mk_optmp1,mk_memvalue
              mov mk_memvalue,#0
              mov mk_optmp0,#0
              testb mk_sr,#MK_EXT_BIT wc
              subsx mk_optmp0,mk_optmp1 wc
              testb mk_optmp0,#31 xorc
              bitc mk_sr,#MK_OVER_BIT
              ' do actual sub
              testb mk_sr,#MK_EXT_BIT wc
              subx mk_memvalue,mk_optmp1 wcz
              muxc mk_sr,#MK_CARRY_MASK|MK_EXT_MASK
              testb mk_optmp0,#31 wc
              bitc mk_sr,#MK_NEG_BIT
              'debug("negx result ",uhex_long(mk_memvalue),ubin(mk_shiftit))
              sar mk_memvalue,mk_shiftit wz
        if_nz bitl mk_sr,#MK_ZERO_BIT
              jmp mk_writef


mk_hub_cmpm
              ' read destination
              getnib pb,mk_opword,#2
              shr pb,#1
              setq #%11_000_000
              muxq pb,mk_opword
              or pb,#%011_000 ' turn into (An)+
              call #mk_setup_operand_auto
              call mk_readf
              mov mk_optmp1,mk_memvalue
              ' read source
              mov pb,mk_opword
              or pb,#%011_000 ' turn into (An)+
              call #mk_setup_operand_auto
              push #mk_cmp_common
              jmp mk_readf

mk_hub_chk
              call #mk_setup_operand16 ' pb already loaded
              call mk_readf
              call #mk_get_second_reg
              andn mk_sr,#MK_OVER_MASK|MK_CARRY_MASK ' Undocumented flags
              cmps mk_optmp1,#0 wcz
              bitz mk_sr,#MK_ZERO_BIT ' Undocumented flag
              mov pb,#$18
        if_b  bith mk_sr,#MK_NEG_BIT
        if_b  jmp #mk_hub_trapit
              cmps mk_optmp1,mk_memvalue wcz
        if_be ret
              bitl mk_sr,#MK_NEG_BIT
              jmp #mk_hub_trapit
{
mk_hub_cogatn
              rdbyte pb,#atn_command wcz
        if_z  jmp #mk_nextop
        if_c  jmp #mk_hub_hotreset
              jmp #mk_hub_cogatn
}

DAT ' MotoKore 68000 init code


              orgh
mk_init
              cogid pa
              decod pa
              wrword pa,#_mk_cogatn_w
              debug(uhex_long_array(#@curpalette_base_l,#1))

              ' load code
              setq #495
              rdlong 0,##@mk_cogbase
              setq2 #511
              rdlong 0,##@mk_lutbase

              ' wait some more
              waitx ##1000000
              rdword mk_romio_atnval,#_ma_cogatn_w


              {
              ' Compute timing constant for H counter emulation
              ' (note that "pixel" here means hcounter values, which are actually 2 pixels)
              rdlong pa,#_clkf
              qmul pa,##round(6.36e-5/211.0*4294967296.0) ' cy/s * s/px -> cy/px
              getqy pa ' cycles per pixel
              getqx pb ' fractional part
              rolword pa,pb,#1
              qfrac #1,pa
              getqx pa ' our timing reciporal
              wrword pa,#vdp_cyc2hcnt_w
              debug("H counter timing constant: ",udec_word_array(#vdp_cyc2hcnt_w,#1))

              ' Compute timing constant for 6-button state machine reset
              rdlong pa,#_clkf
              qdiv pa,##666 ' 1.5 ms - unfortunate reciporal
              getqx pa
              wrlong pa,#io_6btn_timeout

              ' Reset I/O ports (so it seems like we're cold-booting)
              wrbyte #0,#io_pl1_dir
              wrbyte #0,#io_pl2_dir
              wrbyte #0,#io_pl1_out
              wrbyte #0,#io_pl2_out
               }

              ' allocate all the locks like some sort of maniac
              {
              mov pa,#0
              rep @.lockmadness,#16
              locknew pb wc
        if_nc bith pa,pb
.lockmadness
              ' deallocate all the ones we don't want
              andn pa,##STATIC_LOCKS
              mov pb,#0
              rep @.lockmadness2,#16
              shr pa,#1 wc
        if_c  lockret pb
              add pb,#1
.lockmadness2}

{
              rdbyte mk_romio_zerox,#rom_zerox
              sub mk_romio_zerox,#2 ' we apply it to long-unit addresses

              rdlong mk_sram_begin,#sram_map_start
              rdlong mk_sram_stop,#sram_map_end

              ' Reset ROM/SRAM mapping
              rdbyte mk_memvalue,#sram_bankreg
              call #sram_set_bank
}

              ' setup interrupts
              'setse1 #$10+HINT_LOCK
              'setse2 #$10+VINT_LOCK
              'drvl #38 addpins 1 ' DEBUG LEDs

              rdlong mk_prog_base,#_exr_prog_base
              rdlong mk_port_base,#_exr_port_base
              rdlong mk_bios_base,#_exr_bios_base

              debug("before vector cache ",ubin_word(mk_romio_atnval))

              ' cache vector tables
              loc ptra,#mk_vectorcache_game
              mov mk_romio_length,#64
              mov mk_romio_target,ptra
              mov mk_romio_addr,mk_prog_base
              shr mk_romio_addr,#2
              setq #2
              wrlong mk_romio_addr,#_progrq_addr
              cogatn mk_romio_atnval
              waitatn
              ' preswap to little endian
              rep @.vswaplp1,#64
              rdlong pb,ptra
              movbyts pb,#%%0123
              wrlong pb,ptra++
.vswaplp1

              loc ptra,#mk_vectorcache_bios
              mov mk_romio_length,#32
              mov mk_romio_target,ptra
              mov mk_romio_addr,mk_bios_base
              shr mk_romio_addr,#2
              setq #2
              wrlong mk_romio_addr,#_progrq_addr
              cogatn mk_romio_atnval
              waitatn
              ' preswap to little endian
              rep @.vswaplp2,#32
              rdlong pb,ptra
              movbyts pb,#%%0123
              wrlong pb,ptra++
.vswaplp2
              ' copy latter 32 vectors from game
              loc ptrb,#mk_vectorcache_game+32*4
              rep @.vcplp,#32
              rdlong pb,ptrb++
              wrlong pb,ptra++
.vcplp
              debug("after vector cache ",uhex_long_array(#mk_vectorcache_game,#32))
              debug("after vector cache ",uhex_long_array(#mk_vectorcache_bios,#32))
              debug(uhex_long_array(#@curpalette_base_l,#1))

              ' Download Fix tiles
              mov mk_romio_length,#64
              rdlong mk_romio_addr,#_exr_fixt_base
              shr mk_romio_addr,#2
              mov mk_romio_target,##@fix_tiles
              rep @.fixdlloop,##$2_0000/(64*4)
              setq #2
              wrlong mk_romio_addr,#_progrq_addr
              cogatn mk_romio_atnval
              add mk_romio_addr,#64
              add mk_romio_target,#64*4
              waitatn
.fixdlloop
              {
              ' Download M1
              mov mk_romio_length,#64
              rdlong mk_romio_addr,#_exr_z80p_base
              shr mk_romio_addr,#2
              mov mk_romio_target,##@m1_rom
              rep @.z80dlloop,##$2_0000/(64*4)
              setq #2
              wrlong mk_romio_addr,#_progrq_addr
              cogatn mk_romio_atnval
              add mk_romio_addr,#64
              add mk_romio_target,#64*4
              waitatn
.z80dlloop    }


              {
              mov mk_effaddr,##$40_1FFE
              call #mk_setup_ea16
              mov mk_memvalue,#$000F
              call mk_writef
              }


mk_hub_hotreset
              mov mk_vectors_ptr,##mk_vectorcache_bios ' BIOS vectors are selected on reset!
              'wrbyte #0,#atn_command
              mov mk_sr,##MK_SUPER_MASK + (7<<8)
              'call #mk_check_core_integrity
              ' initialize PC and SP
              mov mk_virtualpc,#0
              rdlong mk_branchdisplace,##mk_vectorcache_bios+$04
              rdlong mk_a7,##mk_vectorcache_bios+$00
              debug("inital pc and sp ",uhex_long(mk_branchdisplace),uhex_long(mk_a7))
              mov ptra,#0
              neg mk_romque_left,#1
              jmp #mk_dobranch

              {
mk_check_core_integrity
              loc ptrb,#@mk_nibble_impl_tbl
              mov mk_eatmp1,#mk_nibble_impl_tbl
              'debug("Checking core integrity...")
.chklp
              cmp mk_eatmp1,#mk_cogvar_start wcz
        if_z  ret wcz
              rdlong mk_eatmp0,ptrb++
              alti mk_eatmp1,#%000_000_111
              mov pb,0-0
              cmp mk_eatmp0,pb wz
              ' ignore intentionally self-modifying code
        if_z jmp #.chklp
        if_nz cmp mk_eatmp1,#mk_ihook1+1 wz
        if_nz cmp mk_eatmp1,#mk_ihook2+1 wz
        if_nz cmp mk_eatmp1,#mk_thelogicop+1 wz
        if_nz cmp mk_eatmp1,#mk_romque_left+1 wz
        if_nz cmp mk_eatmp1,#mk_rd8_reg+1 wz
        if_nz cmp mk_eatmp1,#mk_wr8_reg+1 wz
        if_nz cmp mk_eatmp1,#mk_rd16_reg+1 wz
        if_nz cmp mk_eatmp1,#mk_wr16_reg+1 wz
        if_nz cmp mk_eatmp1,#mk_rd32_reg+1 wz
        if_nz cmp mk_eatmp1,#mk_wr32_reg+1 wz
        if_nz cmp mk_eatmp1,#mk_longio_tmp+1 wz
        if_nz cmp mk_eatmp1,#mk_addsuba+8+1 wz
        if_nz cmp mk_eatmp1,#mk_psram_read_cmd+1 wz
        if_z jmp #.chklp
              drvh #39
              sub mk_eatmp1,#1
              debug("Core integrity violation @ ",uhex_(mk_eatmp1)," expected ",uhex_long_(mk_eatmp0)," got ",uhex_long_(pb),dly(#1000))
              add mk_eatmp1,#1
              jmp #.chklp   '}


DAT ' Memory arbiter
              org 0
ma_entry
              cogid pa
              decod pa
              debug("hmmmstve ",udec(pa))
              wrword pa,#_ma_cogatn_w

              ' load LUT code
              setq2 #511
              rdlong 0,##@ma_lutcode

              rdlong ma_char_base,#_exr_char_base
              shr ma_char_base,#2


              fltl #PSRAM_CLK
              wrpin ##P_TRANSITION|P_OE, #PSRAM_CLK
              wxpin #1, #PSRAM_CLK
              drvl #PSRAM_CLK

              wrpin ##P_INVERT_OUTPUT,#PSRAM_SELECT
              drvl #PSRAM_SELECT

              setxfrq ma_nco_slow
              waitx #200


              ' wait some more
              waitx ##5000
              rdword ma_mk_cogatn_val,#_mk_cogatn_w


              mov ijmp2,#ma_68krequest
              setint2 #EVENT_ATN


ma_lineloop
.linewait
              rdlong ma_mtmp1,#video_line_ctr
              sub ma_mtmp1,#1
              cmp ma_mtmp1,ma_curline wz
        if_e  jmp #.linewait
              mov ma_curline,ma_mtmp1
              mov ma_slotleft,#96
              loc ptrb,#spr_buffer
              testb ma_curline,#0 wc
        if_c  add ptrb,##96*4*4
              testb ma_curline,#1 wc
        if_c  add ptrb,##96*4*4*2

.slotlp
              rdlong ma_mtmp1,ptrb[2] wc
        if_c  jmp #ma_lineloop ' got sentinel

              shl     ma_mtmp1,#1 ' sprite lines are 2 longs
              add     ma_mtmp1,ma_char_base
              setbyte ma_mtmp1,#$EB,#3
              splitb  ma_mtmp1
              rev     ma_mtmp1
              movbyts ma_mtmp1, #%%0123
              mergeb  ma_mtmp1
              rep @.irqshield,#1
              drvh  #PSRAM_SELECT
              drvl  ma_psram_pinfield
              xinit ma_psram_addr_cmd,ma_mtmp1
              wypin #(8+PSRAM_WAIT+4)*2,#PSRAM_CLK
              setq ma_nco_fast
              xcont #PSRAM_WAIT*2+PSRAM_DELAY,#0
              wrfast ma_bit31,ptrb
              waitxmt
              fltl ma_psram_pinfield
              setq ma_nco_slow
              xcont ma_psram_readspr_cmd,#0
              waitxfi
              drvl #PSRAM_SELECT
.irqshield
              add ptrb,#4*4
              djnz ma_slotleft,#.slotlp
              'debug("canary alive. Lorem ipsum dolor sit amet. Take it easy!")
              jmp #ma_lineloop


ma_68krequest
              setq #2
              rdlong ma_prog_addr,#_progrq_addr
              debug("Got request ",uhex_long(ma_prog_addr,ma_prog_length,ma_prog_target))


              wrfast ma_bit31,ma_prog_target
              mov ma_itmp2,ma_prog_addr
              add ma_itmp2,ma_prog_length
              mov ma_itmp1,ma_prog_addr
              bith ma_itmp1,#0 addbits 9
              add ma_itmp1,#1 ' ma_itmp1 has start of next page
              cmpsub ma_itmp2,ma_itmp1 wcz ' IF C, ma_itmp2 now has longs that cross over boundary
        if_c  sub ma_prog_length,ma_itmp2
              call #ma_psram_read68k
   if_nc_or_z cogatn ma_mk_cogatn_val
   if_nc_or_z reti2
              mov ma_prog_addr,ma_itmp1
              mov ma_prog_length,ma_itmp2
              call #ma_psram_read68k
              cogatn ma_mk_cogatn_val
              reti2

ma_psram_read68k
              mov ma_itmp0,#(8+PSRAM_WAIT)*2
              shl ma_prog_length,#2
              add ma_itmp0,ma_prog_length
              setbyte ma_prog_addr,#$EB,#3
              ' Reverse nibble order
              splitb  ma_prog_addr
              rev     ma_prog_addr
              movbyts ma_prog_addr, #%%0123
              mergeb  ma_prog_addr
              drvh  #PSRAM_SELECT
              drvl  ma_psram_pinfield
              xinit ma_psram_addr_cmd,ma_prog_addr
              wypin ma_itmp0,#PSRAM_CLK
              setq ma_nco_fast
              xcont #PSRAM_WAIT*2+PSRAM_DELAY,#0
              shr ma_prog_length,#1
              setword ma_psram_read68k_cmd,ma_prog_length,#0
              waitxmt
              fltl ma_psram_pinfield
              setq ma_nco_slow
              xcont ma_psram_read68k_cmd,#0
              waitxfi
        _ret_ drvl #PSRAM_SELECT




ma_bit31      'alias
ma_nco_fast   long $8000_0000
ma_nco_slow   long $4000_0000

ma_psram_pinfield long PSRAM_BASE addpins 15
ma_psram_addr_cmd long (PSRAM_BASE<<17)|X_PINS_ON | X_IMM_8X4_LUT + 8
ma_psram_read68k_cmd long (PSRAM_BASE<<17)|X_WRITE_ON| X_16P_2DAC8_WFWORD
ma_psram_readspr_cmd long (PSRAM_BASE<<17)|X_WRITE_ON| X_16P_2DAC8_WFWORD + 4

ma_prog_addr   res 1
ma_prog_length res 1
ma_prog_target res 1

ma_slotleft res 1
ma_char_base res 1

ma_itmp0      res 1
ma_itmp1      res 1
ma_itmp2      res 1
ma_itmp3      res 1

ma_mtmp0      res 1
ma_mtmp1      res 1
ma_mtmp2      res 1
ma_mtmp3      res 1

ma_curline    res 1

ma_mk_cogatn_val res 1


              fit 496
              org 512
ma_lutcode
              long $0000
              long $1111
              long $2222
              long $3333
              long $4444
              long $5555
              long $6666
              long $7777
              long $8888
              long $9999
              long $AAAA
              long $BBBB
              long $CCCC
              long $DDDD
              long $EEEE
              long $FFFF

              fit 1024

DAT ' I/O glue
              orgh

iog_z80port_wr16
              getbyte mk_memvalue,mk_memvalue,#1
iog_z80port_wr8
              testb mk_eacache,#0 wc
        if_nc wrbyte mk_memvalue,#z80_command_b
        'if_nc wrbyte mk_memvalue,#z80_reply_b ' TODO: actual Z80 comms
              ret wcz

iog_status_a_rd16
              rdbyte mk_memvalue,#z80_reply_b
              rolbyte mk_memvalue,#$1F,#0 ' Does a real AES _have_ a STATUS_A, anyways?
              ret wcz

iog_status_b_rd16
              mov mk_memvalue,#%0011
              rdbyte pa,#io_pl2_padw+1
              rczr pa wcz
              modcz _nc,_nz wcz
              rczl mk_memvalue
              rdbyte pa,#io_pl1_padw+1
              rczr pa wcz
              modcz _nc,_nz wcz
              rczl mk_memvalue
              rolbyte mk_memvalue,#0,#0
              ret wcz

iog_p1stuff_rd16
              rdbyte mk_memvalue,#io_pl1_padw
              xor mk_memvalue,#$FF
              rolbyte mk_memvalue,#0,#0 ' DIPSW or SYSTYPE (again, does AES have these?)
              ret wcz

iog_p2stuff_rd16
              rdbyte mk_memvalue,#io_pl2_padw
              xor mk_memvalue,#$FF
              rolbyte mk_memvalue,#0,#0 ' ????
              ret wcz

iog_latch_wr8
              testb mk_eacache,#0 wc
        if_nc ret wcz
iog_latch_wr16
              testb mk_eacache,#4 wc
              getnib pa,mk_eacache,#0
              shr pa,#1
              cmp pa,#1 wz
        if_01 loc pa,#mk_vectorcache_bios
        if_11 loc pa,#mk_vectorcache_game
        if_x1 mov mk_vectors_ptr,pa
              cmp pa,#7 wz
        if_01 loc pa,#palette32 + 256*16*4
        if_11 loc pa,#palette32 + 0
        if_x1 wrlong pa,#curpalette_base_l
              ret wcz


iog_lspc_wr8
              testb mk_eacache,#0 wc
        if_c  ret wcz
              movbyts mk_memvalue,#%%2200
iog_lspc_wr16
              getnib pa,mk_eacache,#0
              mul pa,#4 ' pa is even to begin with, so interval is 8
              jmprel pa
.lspcwr_base
              orgh .lspcwr_base + 0*8*4 ' Set VRAM address
              getword mk_vram_curr,mk_memvalue,#0
              shl mk_vram_curr,#1
              ret wcz
              orgh .lspcwr_base + 1*8*4 ' Write VRAM
              testb mk_vram_curr,#16 wc
        if_c  jmp #.highvram
              loc pa,#vram_low
              add pa,mk_vram_curr
              wrword mk_memvalue,pa
              add mk_vram_curr,mk_vram_modulo
              setword mk_vram_curr,#0,#1
              ret wcz
              orgh .lspcwr_base + 2*8*4 ' Set modulo
              mov mk_vram_modulo,mk_memvalue
              shl mk_vram_modulo,#1
              ret wcz
              orgh .lspcwr_base + 3*8*4 ' Set LSPC mode
              wrword mk_memvalue,#_lspc_modereg
              ret wcz
              orgh .lspcwr_base + 4*8*4 ' Set timer high word
              ret wcz
              orgh .lspcwr_base + 5*8*4 ' Set timer low word
              ret wcz
              orgh .lspcwr_base + 6*8*4 ' IRQ acknowledge
              testb mk_memvalue,#2 wc
        if_c  setse1 #%000_10_0000 + VINT_LOCK
              testb mk_memvalue,#1 wc
        if_c  setse2 #4 ' TODO: Timer IRQ event
              ret wcz
              orgh .lspcwr_base + 7*8*4 ' PAL-only stuff
              ret wcz
.highvram
              loc pa,#vram_high
              mov mk_memtmp0,mk_vram_curr
              shl mk_memtmp0,#2
              testb mk_vram_curr,#11 wc
              testb mk_vram_curr,#10 wz
              bitc mk_memtmp0,#2
              bitz mk_memtmp0,#1
              zerox mk_memtmp0,#11
              add pa,mk_memtmp0
              wrword mk_memvalue,pa
              add mk_vram_curr,mk_vram_modulo
              setword mk_vram_curr,#1,#1
              ret wcz


iog_lspc_rd16
              getnib pa,mk_eacache,#0
              and pa,#6
              cmpsub pa,#2
              mul pa,#4 ' pa is even to begin with, so interval is 8
              jmprel pa
.lspcrd_base
              orgh .lspcrd_base + 0*8*4 ' Read VRAM
              testb mk_vram_curr,#16 wc
        if_c  jmp #.highvram
              loc pa,#vram_low
              add pa,mk_vram_curr
              rdword mk_memvalue,pa
              ret wcz
              orgh .lspcrd_base + 1*8*4 ' Read modulo
              mov mk_memvalue,mk_vram_modulo
              shr mk_memvalue,#1
              ret wcz
              orgh .lspcrd_base + 2*8*4 ' Read LSPC status
              mov mk_memvalue,#0
              ret wcz
.highvram
              loc pa,#vram_high
              mov mk_memtmp0,mk_vram_curr
              shl mk_memtmp0,#2
              testb mk_vram_curr,#11 wc
              testb mk_vram_curr,#10 wz
              bitc mk_memtmp0,#2
              bitz mk_memtmp0,#1
              zerox mk_memtmp0,#11
              add pa,mk_memtmp0
              rdword mk_memvalue,pa
              ret wcz





DAT ' Palette I/O
              orgh
pal32_wr8
              mov mk_memtmp0,mk_effaddr
              bitl mk_memtmp0,#0 wcz
        if_c  movbyts mk_memvalue,#%%2200
        if_nc movbyts mk_memvalue,#%%3311
              jmp #pal32_wr16_inner

pal32_wr32
              mov mk_longio_tmp,mk_memvalue
              mov mk_memtmp0,mk_effaddr
              add mk_memtmp0,#2
              call #pal32_wr16_inner
              getword mk_memvalue,mk_longio_tmp,#1
              ' Fall through
pal32_wr16
              mov mk_memtmp0,mk_effaddr
pal32_wr16_inner
              debug("in pal32_wr16_inner with ",uhex_long(mk_memtmp0),uhex_long_array(#@curpalette_base_l,#1))
              shl mk_memtmp0,#1
              zerox mk_memtmp0,#13
              rdlong pa,#curpalette_base_l
              add mk_memtmp0,pa
              debug(uhex_long(mk_memtmp0,pa))
              ' Convert %DRGB_RRR_GGG_BBB to truecolor (with black = $01 so we can use WMLONG for blitting)
              mov mk_memtmp2,#1
              testb mk_memvalue,#15 wc
              bitnc mk_memtmp2,#2
              movbyts mk_memtmp2,#%%0000
              setnib mk_memtmp2,mk_memvalue,#3
              shr mk_memvalue,#4
              setnib mk_memtmp2,mk_memvalue,#5
              shr mk_memvalue,#4
              setnib mk_memtmp2,mk_memvalue,#7
              shr mk_memvalue,#5 wc ' gets B0 bit
              bitc mk_memtmp2,#11
              rczr mk_memvalue wcz ' gets R0/G0
              bitz mk_memtmp2,#19
              bitc mk_memtmp2,#27

              wrlong mk_memtmp2,mk_memtmp0
              ret wcz

pal32_rd8
              mov mk_memtmp0,mk_effaddr
              bitl mk_memtmp0,#0 wcz
              call #pal32_rd16_inner
        if_c  getbyte mk_memvalue,mk_memvalue,#0
        if_nc getbyte mk_memvalue,mk_memvalue,#1
              ret wcz

pal32_rd32
              'mov mk_memvalue,#0
              mov mk_memtmp0,mk_effaddr
              shl mk_memtmp0,#1
              call #pal32_rd16_inner
              mov mk_memtmp0,mk_effaddr
              shl mk_memtmp0,#1
              add mk_memtmp0,#4
              jmp #pal32_rd16_inner

pal32_rd16
              mov mk_memvalue,#0
              mov mk_memtmp0,mk_effaddr
              shl mk_memtmp0,#1
pal32_rd16_inner
              zerox mk_memtmp0,#13
              rdlong pa,#curpalette_base_l
              add mk_memtmp0,pa
              rdlong mk_memtmp0,mk_memtmp0
              ' Undo truecolor conversion
              testbn mk_memtmp0,#18 wc ' dark bit (from green channel)
              testb mk_memtmp0,#27 wz ' R0
              rczl mk_memvalue
              testb mk_memtmp0,#19 wc ' G0
              testb mk_memtmp0,#11 wz ' B0
              rczl mk_memvalue
              rolnib mk_memvalue,mk_memtmp0,#7
              rolnib mk_memvalue,mk_memtmp0,#5
              rolnib mk_memvalue,mk_memtmp0,#3

              ret wcz



DAT ' LSPC cog
              org
lspc_entry
              drvl #38 ' DEBUG LED
              '' Generate vertial shrink table
              mov ptra,lspc_shrinkptr
              mov lspc_vshrink,#0
.outer
              mov lspc_tmp1,#0
.inner
              mov lspc_tmp2,lspc_tmp1
              xor lspc_tmp2,#$88
              rev lspc_tmp2
              shr lspc_tmp2,#32-8
              cmp lspc_tmp2,lspc_vshrink wcz
        if_be wrbyte lspc_tmp1,ptra++
              incmod lspc_tmp1,#255 wc
        if_nc jmp #.inner

              incmod lspc_vshrink,#255 wc
        if_nc jmp #.outer

              debug(uhex_byte_array(lspc_shrinkptr,#256))

              'mov lspc_scb3ptr,lspc_vramptr
              'add lspc_scb3ptr,##$8000*2

              'mov lspc_scb1magic,lspc_vramptr
              'add lspc_scb1magic,##381<<7



lspc_linelp
.linewait
              rdlong lspc_tmp1,#video_line_ctr
              'add lspc_tmp1,#3 + 2 ' we're two lines behind the curve
              cmp lspc_tmp1,lspc_curline wz
        if_e  jmp #.linewait
              mov lspc_curline,lspc_tmp1

              rdword lspc_lspcmode,#_lspc_modereg
              testbn lspc_lspcmode,#3 wc
              bitc lspc_auto4msk,#0 addbits 1
              bitc lspc_auto8msk,#0 addbits 2

              '' Generate sprite data for next line
              '' ==================================================

              mov lspc_slotleft,#96
              mov lspc_sprleft,#381
              mov lspc_chkline,lspc_curline
              ' Prepare writing to sprite buffer
              mov ptra,lspc_sprbufptr
              testb lspc_chkline,#0 wc
        if_c  add ptra,##96*4*4
              testb lspc_chkline,#1 wc
        if_c  add ptra,##96*4*4*2

              cmp lspc_chkline,##-1 wz
        if_z  sub lspc_autotimer,#1 wc
        if_11 getbyte lspc_autotimer,lspc_lspcmode,#1
        if_11 incmod lspc_autoframe,#7

              cmp lspc_chkline,##-24 wz
        if_z  locktry #VINT_LOCK wc
        if_z  lockrel #VINT_LOCK
        if_11 drvnot #38

              cmp lspc_chkline,#224 wc
        if_ae jmp #.scan_done ' just fill sentinels if outside of active area

              ' format chkline for fast compares
              subr lspc_chkline,##-16
              shl lspc_chkline,#23

              ' Start iterating reordered high VRAM
              rdfast #0,lspc_vramhiptr
              modc _clr wc
.scanlp
              rflong lspc_tmp1 ' SCB2 in low word, SCB3 in high word
              rflong lspc_tmp4 ' SCB4 in low word, garbo in high word
              testb lspc_tmp1,#6+16 wz ' sticky bit
        if_nz getword lspc_tmp2,lspc_tmp1,#1
        if_nz shl lspc_tmp2,#27 wc ' left justify height. top bit (set->always visible) shifts into C
              sub lspc_tmp1,lspc_chkline
 if_nc_and_nz cmp lspc_tmp1,lspc_tmp2 wc
        if_nc djnz lspc_sprleft,#.scanlp ' 9 op per sprite
        if_nc jmp #.scan_done

              '' Got one! Reel it in, reel it in!
              getword lspc_spry,lspc_tmp1,#1
              shr lspc_spry,#7
              add lspc_tmp1,lspc_chkline ' Undo sub from before to get back SCB2/SCB3
        if_nz getbyte lspc_vshrink,lspc_tmp1,#0
              getnib lspc_hshrink,lspc_tmp1,#2
        if_nz getword lspc_sprx,lspc_tmp4,#0
        if_nz shr lspc_sprx,#7
        if_nz add lspc_sprx,#15
              and lspc_sprx,#511
              ' Vertical computation
              mov lspc_tmp3,lspc_vshrink
              add lspc_tmp3,#1 wc ' just vshrink + 1. Always clears C
              getbyte lspc_tmp2,lspc_spry,#0 ' lookup offset

        if_z  jmp #.sticky ' skip over this part if sticky (flag contention / don't have previous SCB3 anymore)
              testb lspc_spry,#8 wz
        if_z xor lspc_spry,#511
              testbn lspc_tmp1,#16 wc
              testbn lspc_tmp1,#21 orc
        if_nc cmp lspc_spry,lspc_tmp3 wc ' Height 33 special case
        if_nc subr lspc_spry,lspc_tmp3
        if_nc add  lspc_spry,lspc_vshrink
        if_nc modz _nz wz
              and lspc_spry,#255
              cmp lspc_spry,lspc_tmp3 wc
              mul lspc_tmp3,lspc_vshrink
              shr lspc_tmp3,#1
              add lspc_tmp3,lspc_spry
              add lspc_tmp3,lspc_shrinkptr
              ' 26 op here
        if_b  rdbyte lspc_yidx,lspc_tmp3
        if_ae mov lspc_yidx,#$FF
              'mov lspc_yidx,lspc_tmp2 ' DEBUG
        if_z xor lspc_yidx,#511
.sticky       ' 36 op here (non-sticky)
              mov lspc_tmp3,lspc_yidx
              shr lspc_tmp3,#4
              shl lspc_tmp3,#2

              neg lspc_tmp4,lspc_sprleft
              shl lspc_tmp4,#7
              add lspc_tmp4,lspc_tmp3
              add lspc_tmp4,lspc_scb1magic
              ' 43 op here
              rdlong lspc_cromaddr,lspc_tmp4 ' SCB1 data

              getword lspc_attribs,lspc_cromaddr,#1
              getnib lspc_tmp1,lspc_cromaddr,#5 ' get tile ID MSBs
              setword lspc_cromaddr,lspc_tmp1,#1
              testb lspc_attribs,#2 wc' auto4
              testb lspc_attribs,#3 wz' auto8
        if_c  setq lspc_auto4msk
        if_z  setq lspc_auto8msk
        if_not_00 muxq lspc_cromaddr,lspc_autoframe
              rolnib lspc_cromaddr,lspc_yidx,#0
              testb lspc_attribs,#1 wc ' vflip
        if_c  xor lspc_cromaddr,#15

              setword lspc_attribs,lspc_sprx,#1
              setnib lspc_attribs,lspc_hshrink,#1
              setq #3
              ' 65 op here
              wrlong lspc_zero1,ptra++
.nextspr
              add lspc_slotleft,lspc_minus1 wcz ' set Z if last slot was used. Always set C (for addx and sticky check)
              addx lspc_sprx,lspc_hshrink ' Adjust X for potential sticky sprite
        if_nz djnz lspc_sprleft,#.scanlp
              ' 73 op total
.scan_done
              ' Fill remaining slots with sentinel values
              tjz lspc_slotleft, #lspc_linelp
              neg lspc_cromaddr,#1
              neg lspc_attribs,#1
              rep #2,lspc_slotleft
              setq #3
              wrlong lspc_zero1,ptra++

              jmp #lspc_linelp

lspc_minus1  long -1

lspc_vramptr   long @vram_low
lspc_vramhiptr long @vram_high
lspc_shrinkptr long @vshrink_lookup
lspc_sprbufptr long @spr_buffer
lspc_scb1magic long @vram_low + (381<<7)

lspc_curline  long -1
lspc_autoframe long 0
lspc_autotimer long 0
lspc_auto4msk long %11
lspc_auto8msk long %111


lspc_zero1    long $1111_1111*2
lspc_zero2    long $1111_1111
lspc_cromaddr long 0
lspc_attribs  long 0

'lspc_scb3ptr res 1

lspc_tmp1     res 1
lspc_tmp2     res 1
lspc_tmp3     res 1
lspc_tmp4     res 1

lspc_spry     res 1
lspc_yidx     res 1
lspc_sprx     res 1
lspc_vshrink  res 1
lspc_hshrink  res 1
lspc_slotleft res 1
lspc_sprleft  res 1

lspc_chkline  res 1
lspc_lspcmode res 1


DAT ' Blitter cog
              org
blt_entry
              wrlut #0,#0
blt_linelp
.linewait
              rdlong blt_tmp1,blt_linecnt
              sub blt_tmp1,#2
              cmp blt_tmp1,blt_curline wz
        if_e  jmp #.linewait
              mov blt_curline,blt_tmp1
              'debug(udec(blt_curline))

              rdlong blt_colorptr,#curpalette_base_l
              add blt_colorptr,#4

              mov blt_renderptr,blt_renderbase
              testb blt_curline,#0 wc
        if_c add blt_renderptr,##(320+16)*4 '##DRAWBUFFER_WIDTH*4
              mov blt_renderptr_spr,blt_renderptr
              sub blt_renderptr_spr,#15*4

              mov blt_sromline,blt_curline
              and blt_sromline,#7
              mul blt_sromline,#4
              add blt_sromline,blt_sromptr

              ' fill bg color
              mov blt_tmp1,blt_colorptr
              add blt_tmp1,##(256*16-2)*4
              rdlong blt_tmp1,blt_tmp1
              setd .thewr,blt_tmp1
              ror blt_tmp1,#9
              setq blt_augd_mask
              muxq .theaug,blt_tmp1
              nop
              setq #320-1
.theaug       augd #0-0
.thewr        wrlong #0-0,blt_renderptr

              '' Render sprites
              mov blt_slotleft,#96
              mov blt_tmp1,blt_sprbufptr
              testb blt_curline,#0 wc
        if_c  add blt_tmp1,##96*4*4
              testb blt_curline,#1 wc
        if_c  add blt_tmp1,##96*4*4*2
              rdfast #0,blt_tmp1

              jmp #blt_sprloop

blt_shrink_f
              rdlut blt_buffer+0,blt_nibs+0
              rdlut blt_buffer+1,blt_nibs+1
              rdlut blt_buffer+2,blt_nibs+2
              rdlut blt_buffer+3,blt_nibs+3
              rdlut blt_buffer+4,blt_nibs+4
              rdlut blt_buffer+5,blt_nibs+5
              rdlut blt_buffer+6,blt_nibs+6
              rdlut blt_buffer+7,blt_nibs+7
              rdlut blt_buffer+8,blt_nibs+8
              rdlut blt_buffer+9,blt_nibs+9
              rdlut blt_buffer+10,blt_nibs+10
              rdlut blt_buffer+11,blt_nibs+11
              rdlut blt_buffer+12,blt_nibs+12
              rdlut blt_buffer+13,blt_nibs+13
              rdlut blt_buffer+14,blt_nibs+14
              rdlut blt_buffer+15,blt_nibs+15
              setq #15
              wmlong blt_buffer,ptra
blt_sprloop
              djf blt_slotleft,#blt_sprdone
              rflong blt_tpix+0
              rflong blt_tpix+1
              rflong blt_tmp1 wc
        'if_c jmp #blt_sprdone
              rfbyte blt_attr
              rfbyte blt_palette
              rfword ptra

              cmp ptra,#15+320 wc
              getnib blt_tmp1,blt_attr,#1
        if_b  altd blt_tmp1,#blt_shrinktab
              push blt_nodraw

              shl ptra,#2
              add ptra,blt_renderptr_spr

              shl blt_palette,#4+2
              add blt_palette,blt_colorptr
              setq2 #14
              rdlong 1,blt_palette


              'mov blt_tpix+1,##$12345678

              testb blt_attr,#0 wc ' mirror bit
        if_c  jmp #.mirror
              getnib blt_nibs+0,blt_tpix+0,#0
              getnib blt_nibs+1,blt_tpix+0,#1
              getnib blt_nibs+2,blt_tpix+0,#2
              getnib blt_nibs+3,blt_tpix+0,#3
              getnib blt_nibs+4,blt_tpix+0,#4
              getnib blt_nibs+5,blt_tpix+0,#5
              getnib blt_nibs+6,blt_tpix+0,#6
              getnib blt_nibs+7,blt_tpix+0,#7
              getnib blt_nibs+8,blt_tpix+1,#0
              getnib blt_nibs+9,blt_tpix+1,#1
              getnib blt_nibs+10,blt_tpix+1,#2
              getnib blt_nibs+11,blt_tpix+1,#3
              getnib blt_nibs+12,blt_tpix+1,#4
              getnib blt_nibs+13,blt_tpix+1,#5
              getnib blt_nibs+14,blt_tpix+1,#6
        _ret_ getnib blt_nibs+15,blt_tpix+1,#7
.mirror
              getnib blt_nibs+15,blt_tpix+0,#0
              getnib blt_nibs+14,blt_tpix+0,#1
              getnib blt_nibs+13,blt_tpix+0,#2
              getnib blt_nibs+12,blt_tpix+0,#3
              getnib blt_nibs+11,blt_tpix+0,#4
              getnib blt_nibs+10,blt_tpix+0,#5
              getnib blt_nibs+9,blt_tpix+0,#6
              getnib blt_nibs+8,blt_tpix+0,#7
              getnib blt_nibs+7,blt_tpix+1,#0
              getnib blt_nibs+6,blt_tpix+1,#1
              getnib blt_nibs+5,blt_tpix+1,#2
              getnib blt_nibs+4,blt_tpix+1,#3
              getnib blt_nibs+3,blt_tpix+1,#4
              getnib blt_nibs+2,blt_tpix+1,#5
              getnib blt_nibs+1,blt_tpix+1,#6
        _ret_ getnib blt_nibs+0,blt_tpix+1,#7


blt_sprdone
              '' Render Fix layer
              '' =================
              mov ptra,blt_renderptr

              mov ptrb,blt_vramptr
              add ptrb,##$E000
              mov blt_tmp1,blt_curline
              shr blt_tmp1,#3
              add blt_tmp1,#2
              shl blt_tmp1,#1
              add ptrb,blt_tmp1

              rep @.fix_loop,#10

              '' Note: the peculiar instruction order in this loop is to reduce hub latency

              rdlong blt_tile+0,ptrb++[16] ' Use RDLONG so the delta fits (1 cyc penalty sometimes, doesn't matter due to alignment)
              getnib blt_pal+0,blt_tile+0,#3
              shl blt_pal+0,#4+2
              add blt_pal+0,blt_colorptr

              rdlong blt_tile+1,ptrb++[16]
              getnib blt_pal+1,blt_tile+1,#3
              shl blt_pal+1,#4+2
              add blt_pal+1,blt_colorptr

              rdlong blt_tile+2,ptrb++[16]
              getnib blt_pal+2,blt_tile+2,#3
              shl blt_pal+2,#4+2
              add blt_pal+2,blt_colorptr

              rdlong blt_tile+3,ptrb++[16]
              getnib blt_pal+3,blt_tile+3,#3

              zerox blt_tile+0,#11
              shl blt_tile+0,#5
              add blt_tile+0,blt_sromline
              rdlong blt_tpix+0,blt_tile+0

              zerox blt_tile+1,#11
              shl blt_tile+1,#5
              add blt_tile+1,blt_sromline
              rdlong blt_tpix+1,blt_tile+1

              zerox blt_tile+2,#11
              shl blt_tile+2,#5
              add blt_tile+2,blt_sromline
              rdlong blt_tpix+2,blt_tile+2

              zerox blt_tile+3,#11
              shl blt_tile+3,#5
              add blt_tile+3,blt_sromline
              rdlong blt_tpix+3,blt_tile+3


              getnib blt_tmp1,blt_tpix+0,#0

              setq2 #14
              rdlong 1,blt_pal+0

              rdlut blt_buffer+0,blt_tmp1
              getnib blt_tmp1,blt_tpix+0,#1
              rdlut blt_buffer+1,blt_tmp1
              getnib blt_tmp1,blt_tpix+0,#2
              rdlut blt_buffer+2,blt_tmp1
              getnib blt_tmp1,blt_tpix+0,#3
              rdlut blt_buffer+3,blt_tmp1
              getnib blt_tmp1,blt_tpix+0,#4
              rdlut blt_buffer+4,blt_tmp1
              getnib blt_tmp1,blt_tpix+0,#5
              rdlut blt_buffer+5,blt_tmp1
              getnib blt_tmp1,blt_tpix+0,#6
              rdlut blt_buffer+6,blt_tmp1
              getnib blt_tmp1,blt_tpix+0,#7
              rdlut blt_buffer+7,blt_tmp1

              setq2 #14
              rdlong 1,blt_pal+1

              shl blt_pal+3,#4+2
              add blt_pal+3,blt_colorptr

              getnib blt_tmp1,blt_tpix+1,#0
              rdlut blt_buffer+8,blt_tmp1
              getnib blt_tmp1,blt_tpix+1,#1
              rdlut blt_buffer+9,blt_tmp1
              getnib blt_tmp1,blt_tpix+1,#2
              rdlut blt_buffer+10,blt_tmp1
              getnib blt_tmp1,blt_tpix+1,#3
              rdlut blt_buffer+11,blt_tmp1
              getnib blt_tmp1,blt_tpix+1,#4
              rdlut blt_buffer+12,blt_tmp1
              getnib blt_tmp1,blt_tpix+1,#5
              rdlut blt_buffer+13,blt_tmp1
              getnib blt_tmp1,blt_tpix+1,#6
              rdlut blt_buffer+14,blt_tmp1
              getnib blt_tmp1,blt_tpix+1,#7
              rdlut blt_buffer+15,blt_tmp1

              getnib blt_tmp1,blt_tpix+2,#0

              setq2 #14
              rdlong 1,blt_pal+2

              rdlut blt_buffer+16,blt_tmp1
              getnib blt_tmp1,blt_tpix+2,#1
              rdlut blt_buffer+17,blt_tmp1
              getnib blt_tmp1,blt_tpix+2,#2
              rdlut blt_buffer+18,blt_tmp1
              getnib blt_tmp1,blt_tpix+2,#3
              rdlut blt_buffer+19,blt_tmp1
              getnib blt_tmp1,blt_tpix+2,#4
              rdlut blt_buffer+20,blt_tmp1
              getnib blt_tmp1,blt_tpix+2,#5
              rdlut blt_buffer+21,blt_tmp1
              getnib blt_tmp1,blt_tpix+2,#6
              rdlut blt_buffer+22,blt_tmp1
              getnib blt_tmp1,blt_tpix+2,#7
              rdlut blt_buffer+23,blt_tmp1

              setq2 #14
              rdlong 1,blt_pal+3

              getnib blt_tmp1,blt_tpix+3,#0
              rdlut blt_buffer+24,blt_tmp1
              getnib blt_tmp1,blt_tpix+3,#1
              rdlut blt_buffer+25,blt_tmp1
              getnib blt_tmp1,blt_tpix+3,#2
              rdlut blt_buffer+26,blt_tmp1
              getnib blt_tmp1,blt_tpix+3,#3
              rdlut blt_buffer+27,blt_tmp1
              getnib blt_tmp1,blt_tpix+3,#4
              rdlut blt_buffer+28,blt_tmp1
              getnib blt_tmp1,blt_tpix+3,#5
              rdlut blt_buffer+29,blt_tmp1
              getnib blt_tmp1,blt_tpix+3,#6
              rdlut blt_buffer+30,blt_tmp1
              getnib blt_tmp1,blt_tpix+3,#7
              rdlut blt_buffer+31,blt_tmp1

              setq #31
              wmlong blt_buffer,ptra++
.fix_loop
              jmp #blt_linelp

blt_nodraw    long blt_sprloop
blt_shrinktab
              long blt_shrink_0
              long blt_shrink_1
              long blt_shrink_2
              long blt_shrink_3
              long blt_shrink_4
              long blt_shrink_5
              long blt_shrink_6
              long blt_shrink_7
              long blt_shrink_8
              long blt_shrink_9
              long blt_shrink_a
              long blt_shrink_b
              long blt_shrink_c
              long blt_shrink_d
              long blt_shrink_e
              long blt_shrink_f

blt_shrink_0
              rdlut blt_buffer+0,blt_nibs+8
              wmlong blt_buffer,ptra
              jmp #blt_sprloop
blt_shrink_1
              rdlut blt_buffer+0,blt_nibs+4
              rdlut blt_buffer+1,blt_nibs+8
              setq #1
              wmlong blt_buffer,ptra
              jmp #blt_sprloop
blt_shrink_2
              rdlut blt_buffer+0,blt_nibs+4
              rdlut blt_buffer+1,blt_nibs+8
              rdlut blt_buffer+2,blt_nibs+12
              setq #2
              wmlong blt_buffer,ptra
              jmp #blt_sprloop
blt_shrink_3
              rdlut blt_buffer+0,blt_nibs+2
              rdlut blt_buffer+1,blt_nibs+4
              rdlut blt_buffer+2,blt_nibs+8
              rdlut blt_buffer+3,blt_nibs+12
              setq #3
              wmlong blt_buffer,ptra
              jmp #blt_sprloop
blt_shrink_4
              rdlut blt_buffer+0,blt_nibs+2
              rdlut blt_buffer+1,blt_nibs+4
              rdlut blt_buffer+2,blt_nibs+8
              rdlut blt_buffer+3,blt_nibs+12
              rdlut blt_buffer+4,blt_nibs+14
              setq #4
              wmlong blt_buffer,ptra
              jmp #blt_sprloop
blt_shrink_5
              rdlut blt_buffer+0,blt_nibs+2
              rdlut blt_buffer+1,blt_nibs+4
              rdlut blt_buffer+2,blt_nibs+6
              rdlut blt_buffer+3,blt_nibs+8
              rdlut blt_buffer+4,blt_nibs+12
              rdlut blt_buffer+5,blt_nibs+14
              setq #5
              wmlong blt_buffer,ptra
              jmp #blt_sprloop
blt_shrink_6
              rdlut blt_buffer+0,blt_nibs+2
              rdlut blt_buffer+1,blt_nibs+4
              rdlut blt_buffer+2,blt_nibs+6
              rdlut blt_buffer+3,blt_nibs+8
              rdlut blt_buffer+4,blt_nibs+10
              rdlut blt_buffer+5,blt_nibs+12
              rdlut blt_buffer+6,blt_nibs+14
              setq #6
              wmlong blt_buffer,ptra
              jmp #blt_sprloop
blt_shrink_7
              rdlut blt_buffer+0,blt_nibs+0
              rdlut blt_buffer+1,blt_nibs+2
              rdlut blt_buffer+2,blt_nibs+4
              rdlut blt_buffer+3,blt_nibs+6
              rdlut blt_buffer+4,blt_nibs+8
              rdlut blt_buffer+5,blt_nibs+10
              rdlut blt_buffer+6,blt_nibs+12
              rdlut blt_buffer+7,blt_nibs+14
              setq #7
              wmlong blt_buffer,ptra
              jmp #blt_sprloop
blt_shrink_8
              rdlut blt_buffer+0,blt_nibs+0
              rdlut blt_buffer+1,blt_nibs+2
              rdlut blt_buffer+2,blt_nibs+4
              rdlut blt_buffer+3,blt_nibs+6
              rdlut blt_buffer+4,blt_nibs+8
              rdlut blt_buffer+5,blt_nibs+9
              rdlut blt_buffer+6,blt_nibs+10
              rdlut blt_buffer+7,blt_nibs+12
              rdlut blt_buffer+8,blt_nibs+14
              setq #8
              wmlong blt_buffer,ptra
              jmp #blt_sprloop
blt_shrink_9
              rdlut blt_buffer+0,blt_nibs+0
              rdlut blt_buffer+1,blt_nibs+2
              rdlut blt_buffer+2,blt_nibs+3
              rdlut blt_buffer+3,blt_nibs+4
              rdlut blt_buffer+4,blt_nibs+6
              rdlut blt_buffer+5,blt_nibs+8
              rdlut blt_buffer+6,blt_nibs+9
              rdlut blt_buffer+7,blt_nibs+10
              rdlut blt_buffer+8,blt_nibs+12
              rdlut blt_buffer+9,blt_nibs+14
              setq #9
              wmlong blt_buffer,ptra
              jmp #blt_sprloop
blt_shrink_a
              rdlut blt_buffer+0,blt_nibs+0
              rdlut blt_buffer+1,blt_nibs+2
              rdlut blt_buffer+2,blt_nibs+3
              rdlut blt_buffer+3,blt_nibs+4
              rdlut blt_buffer+4,blt_nibs+6
              rdlut blt_buffer+5,blt_nibs+8
              rdlut blt_buffer+6,blt_nibs+9
              rdlut blt_buffer+7,blt_nibs+10
              rdlut blt_buffer+8,blt_nibs+12
              rdlut blt_buffer+9,blt_nibs+14
              rdlut blt_buffer+10,blt_nibs+15
              setq #10
              wmlong blt_buffer,ptra
              jmp #blt_sprloop
blt_shrink_b
              rdlut blt_buffer+0,blt_nibs+0
              rdlut blt_buffer+1,blt_nibs+2
              rdlut blt_buffer+2,blt_nibs+3
              rdlut blt_buffer+3,blt_nibs+4
              rdlut blt_buffer+4,blt_nibs+6
              rdlut blt_buffer+5,blt_nibs+7
              rdlut blt_buffer+6,blt_nibs+8
              rdlut blt_buffer+7,blt_nibs+9
              rdlut blt_buffer+8,blt_nibs+10
              rdlut blt_buffer+9,blt_nibs+12
              rdlut blt_buffer+10,blt_nibs+14
              rdlut blt_buffer+11,blt_nibs+15
              setq #11
              wmlong blt_buffer,ptra
              jmp #blt_sprloop
blt_shrink_c
              rdlut blt_buffer+0,blt_nibs+0
              rdlut blt_buffer+1,blt_nibs+2
              rdlut blt_buffer+2,blt_nibs+3
              rdlut blt_buffer+3,blt_nibs+4
              rdlut blt_buffer+4,blt_nibs+6
              rdlut blt_buffer+5,blt_nibs+7
              rdlut blt_buffer+6,blt_nibs+8
              rdlut blt_buffer+7,blt_nibs+9
              rdlut blt_buffer+8,blt_nibs+10
              rdlut blt_buffer+9,blt_nibs+12
              rdlut blt_buffer+10,blt_nibs+13
              rdlut blt_buffer+11,blt_nibs+14
              rdlut blt_buffer+12,blt_nibs+15
              setq #12
              wmlong blt_buffer,ptra
              jmp #blt_sprloop
blt_shrink_d
              rdlut blt_buffer+0,blt_nibs+0
              rdlut blt_buffer+1,blt_nibs+1
              rdlut blt_buffer+2,blt_nibs+2
              rdlut blt_buffer+3,blt_nibs+3
              rdlut blt_buffer+4,blt_nibs+4
              rdlut blt_buffer+5,blt_nibs+6
              rdlut blt_buffer+6,blt_nibs+7
              rdlut blt_buffer+7,blt_nibs+8
              rdlut blt_buffer+8,blt_nibs+9
              rdlut blt_buffer+9,blt_nibs+10
              rdlut blt_buffer+10,blt_nibs+12
              rdlut blt_buffer+11,blt_nibs+13
              rdlut blt_buffer+12,blt_nibs+14
              rdlut blt_buffer+13,blt_nibs+15
              setq #13
              wmlong blt_buffer,ptra
              jmp #blt_sprloop
blt_shrink_e
              rdlut blt_buffer+0,blt_nibs+0
              rdlut blt_buffer+1,blt_nibs+1
              rdlut blt_buffer+2,blt_nibs+2
              rdlut blt_buffer+3,blt_nibs+3
              rdlut blt_buffer+4,blt_nibs+4
              rdlut blt_buffer+5,blt_nibs+6
              rdlut blt_buffer+6,blt_nibs+7
              rdlut blt_buffer+7,blt_nibs+8
              rdlut blt_buffer+8,blt_nibs+9
              rdlut blt_buffer+9,blt_nibs+10
              rdlut blt_buffer+10,blt_nibs+11
              rdlut blt_buffer+11,blt_nibs+12
              rdlut blt_buffer+12,blt_nibs+13
              rdlut blt_buffer+13,blt_nibs+14
              rdlut blt_buffer+14,blt_nibs+15
              setq #14
              wmlong blt_buffer,ptra
              jmp #blt_sprloop


blt_augd_mask long $007FFFFF

blt_linecnt   long @video_line_ctr
blt_renderbase long @draw_buffer
blt_vramptr  long @vram_low
blt_sromptr   long @fix_tiles
blt_sprbufptr long @spr_buffer

blt_curline   long -1

blt_colorptr  res 1
blt_renderptr res 1
blt_renderptr_spr res 1
blt_sromline  res 1
blt_tmp1      res 1
blt_tmp2      res 1
blt_tmp3      res 1
blt_tmp4      res 1
blt_tiles     res 1
blt_slotleft  res 1
blt_attr      res 1
blt_palette   res 1

blt_tpix      res 4

blt_tile      res 4
blt_pal       res 4

blt_buffer    res 32
blt_nibs      res 16

              fit 496

CON ' ZiKore constants

ZK_HLOP = 1<<10

ZK_CARRY_BIT = 0
ZK_NMODE_BIT = 1
ZK_OVER_BIT  = 2 ' also parity
ZK_HALF_BIT  = 4
ZK_ZERO_BIT  = 6
ZK_SIGN_BIT  = 7

ZK_XYMASK     = %0010_1000
ZK_SIGNXYMASK = %1010_1000

ZK_IFF1_BIT = 0
ZK_IFF2_BIT = 1


DAT ' ZiKore Z80 cog resident code
              org
zk_cogbase



zk_nextop
              'debug("skip canary")
              'debug(udec(zk_cycles)," elapsed",uhex_word(zk_pc))



zk_irqhook    nop
              {
              cmp zk_pc,##$06B2 wz
        'if_nz cmp zk_pc,##$06EF wz
        if_nz cmp zk_pc,##$06D2 wz
        'if_nz cmp zk_pc,##$044E wz
        'if_nz cmp zk_pc,##$0451 wz
        if_nz jmp #.nodebug          '}
              'debug(uhex_word(zk_pc),uhex_long(zk_debc),uhex_word(zk_hl,zk_sp),uhex_byte(zk_accu),ubin_byte(zk_flags))
              'debug(uhex_byte_array(#@fakemem+$FFF0,#16))
.nodebug
              mul zk_cycles,zk_cycletime
              add zk_cycles,zk_lastwait
              getct pa
              sub zk_cycles,pa
              cmps zk_cycles,#1 wc
        if_ae waitx zk_cycles
              getct zk_lastwait

              mov zk_cycles,#1

              mov zk_temphl,zk_hl
              mov zk_hlptr,#zk_hl
              mov zk_tempidx,zk_hl
              mov zk_prefix,#0
              incmod zk_refresh,#127

              call #zk_readcode
              mov zk_opcode,zk_tmp8
              'debug(uhex_byte(zk_opcode))
              rdlut zk_opimpl,zk_opcode
              'debug(uhex_long(zk_opimpl))
              bitl zk_opimpl,#10 wcz ' first instruction can't be skipped, use as flag for (HL) ops
              push #zk_nextop
              execf zk_opimpl

zk_iyprefix
              mov zk_hlptr,#zk_iy
zk_ixprefix
              mov zk_hlptr,#zk_ix

              mov zk_prefix,zk_opcode
              incmod zk_refresh,#127
              add zk_cycles,#1


              call #zk_readcode
              mov zk_opcode,zk_tmp8
              rdlut zk_opimpl,zk_opcode
              bitl zk_opimpl,#10 wcz ' first instruction can't be skipped, use as flag for (HL) ops
        if_nc jmp #.nodisplace
              ' handle index displacement
              mov zk_temphl,zk_hl
              alts zk_hlptr
              mov zk_tempidx,0-0
              mov zk_hlptr,#zk_hl
              call #zk_readcode
              signx zk_tmp8,#7
              add zk_tempidx,zk_tmp8
              execf zk_opimpl

.nodisplace
              alts zk_hlptr
              mov zk_temphl,0-0
              mov zk_tempidx,zk_temphl
              execf zk_opimpl


zk_bitprefix
              call #\zk_readcode
              mov zk_opcode,zk_tmp8
              add zk_cycles,#1
              incmod zk_refresh,#127

              cmp zk_prefix,#0 wz
        if_z  call #zk_getrz
        if_nz call #zk_read8hl

              mov pa,zk_opcode
              shr pa,#3
              and pa,#7

              testb zk_opcode,#7 wc
              testb zk_opcode,#6 wz
        if_00 jmp #.shift
        if_01 jmp #.bit
              bitz zk_tmp8,pa
              ' write result (slightly complex)
              mov pa,zk_opcode
              and pa,#7
              cmp pa,#6 wz
        if_nz cmp zk_prefix,#0 wz
        if_nz push #zk_write8hl
              jmp #\zk_setrz


.bit
              decod pa
              and pa,zk_tmp8 wz
              muxz zk_flags,#(1<<ZK_ZERO_BIT)|(1<<ZK_OVER_BIT)
              bitl zk_flags,#ZK_NMODE_BIT
              bith zk_flags,#ZK_HALF_BIT
              setq #1<<ZK_SIGN_BIT
              muxq zk_flags,pa
              setq #ZK_XYMASK
        _ret_ muxq zk_flags,zk_tmp8


.shift
              push #.shiftdone
              altd pa,#zk_shift_impl_tbl
              execf 0-0

.shiftdone
              ' write result (slightly complex)
              mov pa,zk_opcode
              and pa,#7
              cmp pa,#6 wz
        if_nz cmp zk_prefix,#0 wz
        if_nz push #zk_write8hl
              jmp #\zk_setrz


zk_shift_impl_tbl
              long zk_shiftop + (%1_001_110_01_11110_0<<10) ' RLC
              long zk_shiftop + (%1_001_001_01_11011_0<<10) ' RRC
              long zk_shiftop + (%1_001_110_00_11110_0<<10) ' RL
              long zk_shiftop + (%1_001_001_00_11011_0<<10) ' RR
              long zk_shiftop + (%1_001_110_01_01110_0<<10) ' SLA
              long zk_shiftop + (%1_001_011_01_11000_0<<10) ' SRA
              long zk_shiftop + (%1_001_110_01_10110_0<<10) ' SLL
              long zk_shiftop + (%1_001_011_01_11011_0<<10) ' SRL


zk_extprefix
              call #\zk_readcode
              mov zk_opcode,zk_tmp8
              add zk_cycles,#1
              incmod zk_refresh,#127
              'debug("extend ",uhex_byte(zk_opcode))

              cmp zk_opcode,#$A0 wc
        if_ae jmp #.blockop
              cmp zk_opcode,#$40 wc
        if_b  ret

              mov pa,zk_opcode
              and pa,#7
              altd pa,#zk_ext_impl_tbl
              execf 0-0

.blockop
              '' The undocumented flags on these are cursed.
              test zk_opcode,#%0100_0100 wz
        if_nz ret ' NOP
              rczr zk_opcode wcz ' get operation type into cz
        if_00 add zk_cycles,#2
        if_01 add zk_cycles,#5
        if_1x add zk_cycles,#1
        if_00 skipf ##%00000000_11111_11111_01_1111110_1110_011_111111 ' LD
        if_01 skipf ##%00000011_01010_00000_10_0011110_1101_011_1111   ' CP
        if_10 skipf ##%00001111_10101_11101_01_1100011_0011_100_11     ' IN
        if_11 skipf ##%00111111_10101_11101_01_1111101_0011_011        ' OUT

              getbyte zk_ea,zk_debc,#0 ' IN
              call #\zk_portin ' IN
              call #\zk_read8hl ' everything else

              andn zk_flags,#(1<<ZK_NMODE_BIT)|(1<<ZK_HALF_BIT) ' LD
              bith zk_flags,#ZK_NMODE_BIT ' CP
              testb zk_tmp8,#7 wc ' IN/OUT
              bitc zk_flags,#ZK_NMODE_BIT ' IN/OUT

              mov zk_optmp0,zk_accu ' LD CP
              getbyte zk_optmp0,zk_hl,#0 ' OUT
              getbyte zk_optmp0,zk_debc,#0 ' IN
              testb zk_opcode,#1 wc ' IN
              sumc zk_optmp0,#1 ' IN
              mov zk_optmp1,zk_tmp8 ' CP
              xor zk_optmp1,zk_optmp0 ' CP

              sub zk_optmp0,zk_tmp8 ' CP only
              add zk_optmp0,zk_tmp8 ' LD,IN,OUT

              xor zk_optmp1,zk_optmp0 ' CP
              and zk_optmp0,#255 wz ' CP,IN,OUT
              bitz zk_flags,#ZK_ZERO_BIT ' CP
              testb zk_optmp0,#7 wc ' CP
              bitc  zk_flags,#ZK_SIGN_BIT ' CP

              testb zk_optmp1,#4 wc   ' CP
              cmpr zk_optmp0,#255 wc  ' IN/OUT
              bitc zk_flags,#ZK_HALF_BIT ' CP
              muxc zk_flags,#(1<<ZK_HALF_BIT)|(1<<ZK_CARRY_BIT) ' IN/OUT
        if_c  sub zk_optmp0,#1  ' CP (subtract HF again for XY flag purposes)

              skipf ##%000_00_000_01_11100100_11001_1111_0000_111111 ' LD
              skipf ##%000_00_111_00_11100100_11111_1111_0000_1111 ' CP
              skipf ##%000_00_111_01_00011001_11010_0000_1111_11   ' IN
              skipf ##%000_00_111_01_00011001_00111_0000_1111      ' OUT


              testb zk_optmp0,#1 wc ' LD,CP
              bitc zk_flags,#5 'LD,CP (sets YF)
              testb zk_optmp0,#3 wc ' LD,CP
              bitc zk_flags,#3 'LD,CP (sets XF)

              getbyte zk_optmp1,zk_debc,#1 ' IN,OUT (get B)
              and zk_optmp0,#7 ' IN,OUT
              xor zk_optmp0,zk_optmp1 wc ' IN,OUT
              bitnc zk_flags,#ZK_OVER_BIT ' IN,OUT

              mov zk_ea,zk_hl  ' IN
              getword zk_ea,zk_debc,#1 ' LD
              call #\zk_write8 ' LD,IN
              getbyte zk_ea,zk_debc,#0 ' OUT
              call #\zk_portout ' OUT

              getword zk_optmp1,zk_debc,#0 ' LD,CP
              decmod zk_optmp1,zk_ffffh wz ' all
              setbyte zk_debc,zk_optmp1,#1 ' IN/OUT
              setword zk_debc,zk_optmp1,#0 ' LD,CP
              bitnz zk_flags,#ZK_OVER_BIT ' LD,CP
              bitz zk_flags,#ZK_ZERO_BIT ' IN,OUT
              setq #ZK_SIGNXYMASK ' IN,OUT
              muxq zk_flags,zk_optmp1 ' IN,OUT

              testb zk_flags,#ZK_ZERO_BIT orz ' CP (A==(HL) can also trigger CPxR break)
              testb zk_opcode,#1 wc ' Get direction (C = dec)

        if_nc incmod zk_ea,zk_ffffh    ' LD
        if_c  decmod zk_ea,zk_ffffh    ' LD
              setword zk_debc,zk_ea,#1 ' LD

        if_nc incmod zk_hl,zk_ffffh
        if_c  decmod zk_hl,zk_ffffh

              testb zk_opcode,#2 wc ' Is repeat code?
 if_c_and_nz  sub zk_pc,#2
 if_c_and_nz  add zk_cycles,#5
              'debug(uhex_byte(zk_tmp8),uhex_long(zk_debc),ubin_byte(zk_flags))
              ret

zk_ext_impl_tbl
              long zk_cio + (%10_11_11_000000<<10) ' IN [BCDEHL0A],(C)
              long zk_cio + (%00_01_11_000000<<10) ' OUT (C),[BCDEHL0A]
              long zk_ext_differentiate + (%0_110_000<<10) ' ADC/SBC with HL
              long zk_ext_differentiate + (%0_101_000<<10) ' 16 bit LD from to (imm16)
              long zk_neg
              long zk_irqret
              long zk_imode
              long zk_ext_differentiate + (%0_011_000<<10) ' miscellany


zk_ext_differentiate
              mov pa,zk_opcode
              shr pa,#3
              and pa,#7

              altd pa,#zk_extmath16_impl_tbl
              altd pa,#zk_extld16_impl_tbl
              altd pa,#zk_extmisc_impl_tbl

              execf 0-0

zk_extmath16_impl_tbl
              long zk_cmath16 + (%0100_000_00_0011_00_1110_0<<10) ' SBC HL,BC
              long zk_cmath16 + (%0100_000_00_1100_00_1110_0<<10) ' ADC HL,BC
              long zk_cmath16 + (%0100_000_00_0011_00_1101_0<<10) ' SBC HL,DE
              long zk_cmath16 + (%0100_000_00_1100_00_1101_0<<10) ' ADC HL,DE
              long zk_cmath16 + (%0100_000_00_0011_00_1011_0<<10) ' SBC HL,HL
              long zk_cmath16 + (%0100_000_00_1100_00_1011_0<<10) ' ADC HL,HL
              long zk_cmath16 + (%0100_000_00_0011_00_0111_0<<10) ' SBC HL,SP
              long zk_cmath16 + (%0100_000_00_1100_00_0111_0<<10) ' ADC HL,SP

zk_extld16_impl_tbl
              long zk_ld_abs16 + (%01110_00<<10) ' LD (imm16),BC
              long zk_ld_abs16 + (%00_11111_00<<10) ' LD BC,(imm16)
              long zk_ld_abs16 + (%01101_00<<10) ' LD (imm16),DE
              long zk_ld_abs16 + (%010_11111_00<<10) ' LD DE,(imm16)
              long zk_ld_abs16 + (%01011_00<<10) ' LD (imm16),HL
              long zk_ld_abs16 + (%00110_11111_00<<10) ' LD HL,(imm16)
              long zk_ld_abs16 + (%00111_00<<10) ' LD (imm16),SP
              long zk_ld_abs16 + (%01110_11111_00<<10) ' LD SP,(imm16)

zk_extmisc_impl_tbl
              long zk_a2i                       ' LD I,A
              long zk_a2r                       ' LD R,A
              long zk_i2a                       ' LD A,I
              long zk_r2a  + (%1_000<<10)       ' LD A,R
              long zk_rxd + (%000_111_00<<10)   ' RRD
              long zk_rxd + (%111_000_00<<10)   ' RLD
              long zk_nextop                    ' NOP
              long zk_nextop                    ' NOP


zk_rxd
              call #\zk_read8hl
              add zk_cycles,#4
              ' RLD
              rolnib zk_tmp8,zk_accu,#0
              getnib pa,zk_tmp8,#2
              setnib zk_tmp8,#0,#2
              ' RRD
              setnib zk_tmp8,zk_accu,#2
              getnib pa,zk_tmp8,#0
              shr zk_tmp8,#4

              setnib zk_accu,pa,#0
              andn zk_flags,#(1<<ZK_HALF_BIT)|(1<<ZK_NMODE_BIT)
              and zk_accu,#$FF wcz
              bitz zk_flags,#ZK_ZERO_BIT
              bitnc zk_flags,#ZK_OVER_BIT
              setq #ZK_SIGNXYMASK
              muxq zk_flags,zk_accu
              jmp #\zk_write8hl

zk_a2r
              mov zk_refresh,zk_accu
              and zk_refresh,#$7F
        _ret_ mov zk_refreshhi,zk_accu

zk_a2i
        _ret_ mov zk_ivector,zk_accu

zk_r2a
              mov zk_accu,zk_refresh
              setq #$80
              muxq zk_accu,zk_refreshhi
zk_i2a
              mov zk_accu,zk_ivector

              and zk_accu,#$FF wcz
              bitz zk_flags,#ZK_ZERO_BIT
              test zk_irqenable,#ZK_IFF2_BIT wc
              bitc zk_flags,#ZK_OVER_BIT
              andn zk_flags,#(1<<ZK_NMODE_BIT)|(1<<ZK_HALF_BIT)
              setq #ZK_SIGNXYMASK
        _ret_ muxq zk_flags,zk_accu




zk_irqret     '' RETI/RETN
              '' These are literally the same
              testb zk_irqenable,#ZK_IFF2_BIT wc
              bitc zk_irqenable,#ZK_IFF1_BIT
              call #\zk_pop16
        _ret_ mov zk_pc,zk_tmp16


zk_imode      ' Don't care, always assume IM1
              ret
zk_irqoff
              andn zk_irqenable,#(1<<ZK_IFF1_BIT)|(1<<ZK_IFF2_BIT)
        _ret_ mov zk_irqhook,#0
zk_irqon
              or zk_irqenable,#(1<<ZK_IFF1_BIT)|(1<<ZK_IFF2_BIT)
        _ret_ mov zk_irqhook,##(%1111_1011110_010_000000100<<9)+zk_irqptr ' JSE1 zk_irqptr

zk_irqptr     long zk_doirq
zk_doirq
              andn zk_irqenable,#(1<<ZK_IFF1_BIT)
              mov zk_irqhook,#0
              mov zk_tmp16,zk_pc
              call #\zk_push16
              mov zk_pc,#$38
              jmp #\zk_nextop


zk_jump_indir
        _ret_ mov zk_pc,zk_temphl
zk_hl_to_sp
              add zk_cycles,#2
        _ret_ mov zk_sp,zk_temphl

zk_jump
              call #\zk_readcode16
zk_condret
              add zk_cycles,#1 ' Extra cycle in conditional RET

              testb zk_flags,#ZK_ZERO_BIT wc
              testb zk_flags,#ZK_CARRY_BIT wc
              testb zk_flags,#ZK_OVER_BIT wc
              testb zk_flags,#ZK_SIGN_BIT wc

              modc _nc wc
        if_c  call #\zk_nextop
zk_ret
              call #zk_pop16
              mov zk_optmp0,zk_tmp16 ' For every op!
zk_rst
              mov zk_optmp0,zk_opcode
              and zk_optmp0,#%00111000
zk_pushjmp
              mov zk_tmp16,zk_pc
              mov zk_pc,zk_optmp0
              jmp #\zk_push16
              ret



zk_getrz      ' Get value as indicated by opcode Z field
              mov pa,zk_opcode
              and pa,#7
              'debug("in zk_getrz ",uhex_byte(pa))
              add pa,#zk_getrpa-$-1
              jmprel pa
zk_getry      ' Get value as indicated by opcode Y field
              mov pa,zk_opcode
              shr pa,#3
              and pa,#7
zk_getrpa
              jmprel pa
        _ret_ getbyte zk_tmp8,zk_debc,#1   ' B register
        _ret_ getbyte zk_tmp8,zk_debc,#0   ' C register
        _ret_ getbyte zk_tmp8,zk_debc,#3   ' D register
        _ret_ getbyte zk_tmp8,zk_debc,#2   ' E register
        _ret_ getbyte zk_tmp8,zk_temphl,#1 ' H register
        _ret_ getbyte zk_tmp8,zk_temphl,#0 ' L register
              jmp #zk_read8hl              ' (HL)
        _ret_ getbyte zk_tmp8,zk_accu,#0   ' A register

zk_setrz      ' Get value as indicated by opcode Z field
              mov pa,zk_opcode
              and pa,#7
              add pa,#zk_setrpa-$-1
              jmprel pa
zk_setry      ' Get value as indicated by opcode Y field
              mov pa,zk_opcode
              shr pa,#3
              and pa,#7
              'debug("in zk_setry ",uhex_byte(pa,zk_tmp8))
zk_setrpa     jmprel pa
        _ret_ setbyte zk_debc,zk_tmp8,#1   ' B register
        _ret_ setbyte zk_debc,zk_tmp8,#0   ' C register
        _ret_ setbyte zk_debc,zk_tmp8,#3   ' D register
        _ret_ setbyte zk_debc,zk_tmp8,#2   ' E register
              jmp #.seth                   ' H register
              jmp #.setl                   ' L register
              jmp #zk_write8hl             ' (HL)
        _ret_ setbyte zk_accu,zk_tmp8,#0   ' A register

.seth
              setbyte zk_temphl,zk_tmp8,#1
              altd zk_hlptr
        _ret_ mov 0-0,zk_temphl
.setl
              setbyte zk_temphl,zk_tmp8,#0
              altd zk_hlptr
        _ret_ mov 0-0,zk_temphl

zk_push16
              add zk_cycles,#1
              sub zk_sp,#2
              setword zk_sp,#0,#1
              mov zk_ea,zk_sp
              jmp #zk_write16
zk_pop16
              mov zk_ea,zk_sp
              add zk_sp,#2
              setword zk_sp,#0,#1
              jmp #zk_read16

zk_read16hl
              getword zk_ea,zk_tempidx,#0
zk_read16
              call #zk_read8
              getbyte zk_tmp16,zk_tmp8,#0
              add zk_ea,#1
              call #zk_read8
              setbyte zk_tmp16,zk_tmp8,#1
        _ret_ sub zk_ea,#1

zk_read8hl
              getword zk_ea,zk_tempidx,#0
              jmp #zk_read8
zk_readcode
              mov zk_ea,zk_pc
              incmod zk_pc,zk_ffffh
              setword zk_pc,#0,#1
              ' fall through
zk_read8
              add zk_cycles,#3

              mov pa,zk_ea
              modcz _clr,_set wcz
        if_x1 cmpsub pa,zk_ramstart wc
        if_11 add pa,zk_ramptr wz
        if_x1 cmpsub pa,zk_bank0start wc
        if_11 add pa,zk_bank0ptr wz
        if_x1 cmpsub pa,zk_bank1start wc
        if_11 add pa,zk_bank1ptr wz
        if_x1 cmpsub pa,zk_bank2start wc
        if_11 add pa,zk_bank2ptr wz
        if_x1 cmpsub pa,zk_bank3start wc
        if_11 add pa,zk_bank3ptr wz
        if_01 add pa,zk_staticptr

              rdbyte zk_tmp8,pa
              ret wcz


zk_readcode16
              call #zk_readcode
              getbyte zk_tmp16,zk_tmp8,#0
              call #zk_readcode
        _ret_ setbyte zk_tmp16,zk_tmp8,#1

zk_write16hl
              getword zk_ea,zk_tempidx,#0
zk_write16
              getbyte zk_tmp8,zk_tmp16,#0
              call #zk_write8
              add zk_ea,#1
              getbyte zk_tmp8,zk_tmp16,#1
              call #zk_write8
        _ret_ sub zk_ea,#1


zk_write8hl
              getword zk_ea,zk_tempidx,#0
zk_write8
           {  cmp zk_ea,##$FFF8 wz
        if_nz cmp zk_ea,##$FFF9 wz
        if_nz jmp #.nodebug
              debug("write monitor! ",uhex_word(zk_ea),uhex_byte(zk_tmp8))     }
              'debug("in zk_read8 ",uhex_word(zk_ea))
.nodebug
              add zk_cycles,#3

              mov pa,zk_ea
              cmpsub pa,zk_ramstart wc
        if_c  add pa,zk_ramptr
        if_c  wrbyte zk_tmp8,pa
              ret wcz

zk_portout
              add zk_cycles,#4
              'debug("PORT OUT ",uhex_byte(zk_ea,zk_tmp8)," : "{, zk_tmp8} )
              'tjnz zk_ea,#.nope
              'debug(`ZTerm `(zk_tmp8))
.nope
              testb zk_ea,#3 wc
              testb zk_ea,#2 wz
              '' TODO: if_01 access YM2610
        if_00 wrbyte #0,#z80_command_b
        if_11 wrbyte zk_tmp8,#z80_reply_b
              '' TODO: if_10 enable/disable NMI

              ret wcz

zk_portin
              add zk_cycles,#4
              'debug("PORT IN ",uhex_byte(zk_ea))
              testb zk_ea,#3 wc
              testb zk_ea,#2 wz
              '' TODO: if_01 access YM2610
        if_10 jmp #.bankset
        if_00 rdbyte zk_tmp8,#z80_command_b
              '' TODO: acknowledge NMI
        if_11 mov zk_tmp8,#$FF ' Not sure what this should do
              ret wcz
.bankset
              cmp zk_opcode,#$DB wz ' IN A,(imm8) opcode
        if_z  getbyte zk_memtmp0,zk_accu,#0
        if_nz getbyte zk_memtmp0,zk_debc,#1
              mov pa,zk_ea
              and pa,#3
              shl zk_memtmp0,#11
              shl zk_memtmp0,pa
              zerox zk_memtmp0,#16 ' Limit to 128k
              altr pa,#zk_bank0ptr
              add zk_memtmp0,zk_staticptr
              ret wcz



zk_ramstart   long $F800
zk_bank0start long $F000
zk_bank1start long $E000
zk_bank2start long $C000
zk_bank3start long $8000

zk_ramptr     long @z80_ram
zk_bank0ptr   long @m1_rom
zk_bank1ptr   long @m1_rom
zk_bank2ptr   long @m1_rom
zk_bank3ptr   long @m1_rom
zk_staticptr  long @m1_rom

zk_ffffh      long $FFFF
zk_18000h     long $18000
zk_bit31      long  negx

zk_cycles     long 0
zk_pc         long $0100


zk_flags      long 0
zk_accu       long 0
zk_debc       long 0
zk_sp         long 0
zk_hl         long 0
zk_ix         long 0
zk_iy         long 0
zk_altflags   long 0
zk_altaccu    long 0
zk_altdebc    long 0
zk_althl      long 0
zk_refresh    long 0
zk_refreshhi  long 0
zk_ivector    long 0
zk_irqenable  long 0


zk_cycletime  long CLK_MULTIPLIER*6
zk_lastwait   res 1

zk_opcode     res 1
zk_opimpl     res 1
zk_prefix     res 1
zk_temphl     res 1
zk_tempidx    res 1
zk_hlptr      res 1
zk_tmp16      res 1

zk_optmp0     res 1
zk_optmp1     res 1


              fit $1F0
              org $1F0
zk_memtmp0    res 1
zk_memtmp1    res 1
zk_memtmp2    res 1
zk_memtmp3    res 1
zk_tmp8       res 1 ' memory read/write value
zk_ea         res 1 ' remapped EA
              fit $1F6

DAT ' ZiKore Z80 LUT resident code
              org $200
zk_lutbase
              '' Opcode table
              long zk_nextop                            ' $00: NOP
              long zk_loadimm16 + (%0000_1_111_0<<10)   ' $01: LD BC,imm16
              long zk_a_and_ptr + (%001110<<10)         ' $02: LD (BC),A
              long zk_incdec16+(%0000_1_1111_10_1_11100<<10) ' $03: INC BC
              long zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10) ' $04: INC B
              long zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10) ' $05: DEC B
              long zk_loadimm8                          ' $06: LD B,imm8
              long zk_rolla+(%0_010_110_01_11110_00<<10) ' $07: RLCA
              long zk_ex_af                             ' $08: EX AF,AF'
              long zk_math16+(%0010_111_00_1100_00_1110_1_0<<10) ' $09: ADD HL,BC
              long zk_a_and_ptr + (%000010<<10)         ' $0A: LD A,(BC)
              long zk_incdec16+(%0000_1_1111_01_1_11100<<10) ' $0B: DEC BC
              long zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10) ' $0C: INC C
              long zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10) ' $0D: DEC C
              long zk_loadimm8                          ' $0E: LD C,imm8
              long zk_rolla+(%0_010_001_01_11011_00<<10) ' $0F: RRCA
              long zk_jr + (%01_11_0000_0<<10)          ' $10: DJNZ
              long zk_loadimm16 + (%0001_1_111_0<<10)   ' $11: LD DE,imm16
              long zk_a_and_ptr + (%00110 <<10)+1       ' $12: LD (DE),A
              long zk_incdec16+(%0001_1_1111_10_1_11010<<10) ' $13: INC DE
              long zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10) ' $14: INC D
              long zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10) ' $15: DEC D
              long zk_loadimm8                          ' $16: LD D,imm8
              long zk_rolla+(%0_010_110_00_11110_00<<10) ' $17: RLA
              long zk_jr + (%11_11_1111_0<<10)          ' $18: JR
              long zk_math16+(%0010_111_00_1100_00_1101_1_0<<10) ' $19: ADD HL,DE
              long zk_a_and_ptr + (%00000 <<10)+1       ' $1A: LD A,(DE)
              long zk_incdec16+(%0001_1_1111_01_1_11010<<10) ' $1B: DEC DE
              long zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10) ' $1C: INC E
              long zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10) ' $1D: DEC E
              long zk_loadimm8                          ' $1E: LD E,imm8
              long zk_rolla+(%0_010_001_00_11011_00<<10) ' $1F: RRA
              long zk_jr + (%01_10_1111_0<<10)          ' $20: JR NZ
              long zk_loadimm16 + (%0011_1_111_0<<10)   ' $21: LD HL,imm16
              long zk_ld_abs16 + (%01011_00<<10)        ' $22: LD (imm16),HL
              long zk_incdec16+(%0011_1_1111_10_1_10110<<10) ' $23: INC HL
              long zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10) ' $24: INC H
              long zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10) ' $25: DEC H
              long zk_loadimm8                          ' $26: LD H,imm8
              long zk_daa                               ' $27: DAA
              long zk_jr + (%00_10_1111_0<<10)          ' $28: JR Z
              long zk_math16+(%0010_111_00_1100_00_1011_1_0<<10) ' $29: ADD HL,HL
              long zk_ld_abs16 + (%00110_11111_00<<10)  ' $2A: LD HL,(imm16)
              long zk_incdec16+(%0011_1_1111_01_1_10110<<10) ' $2B: DEC HL
              long zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10) ' $2C: INC L
              long zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10) ' $2D: DEC L
              long zk_loadimm8                          ' $2E: LD L,imm8
              long zk_cpl                               ' $2F: CPL
              long zk_jr + (%01_01_1111_0<<10)          ' $30: JR NC
              long zk_loadimm16 + (%0111_1_111_0<<10)   ' $31: LD SP,imm16
              long zk_ld_abs + (%001111_00<<10)         ' $32: LD (imm16),A
              long zk_incdec16+(%0111_1_1111_10_1_01110<<10) ' $33: INC SP
              long zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10)+ZK_HLOP ' $34: INC (HL)
              long zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10)+ZK_HLOP ' $35: DEC (HL)
              long zk_loadimm8 + ZK_HLOP                ' $36: LD (HL),imm8
              long zk_scf + (%10 << 10)                 ' $37: SCF
              long zk_jr + (%00_01_1111_0<<10)          ' $38: JR C
              long zk_math16+(%0010_111_00_1100_00_0111_1_0<<10) ' $39: ADD HL,SP
              long zk_ld_abs + (  %0011_00<<10)         ' $3A: LD A,(imm16)
              long zk_incdec16+(%0111_1_1111_01_1_01110<<10)' $3B: DEC SP
              long zk_incdec8+(%01_11_00_0110_1100_0_10_1111_00<<10) ' $3C: INC A
              long zk_incdec8+(%01_11_00_0110_0011_0_10_1111_00<<10) ' $3D: DEC A
              long zk_loadimm8                          ' $3E: LD A,imm8
              long zk_ccf                               ' $3F: CCF
              long zk_nextop                            ' $40: LD B,B (NOP)
              long zk_regmove                           ' $41: LD B,C
              long zk_regmove                           ' $42: LD B,D
              long zk_regmove                           ' $43: LD B,E
              long zk_regmove                           ' $44: LD B,H
              long zk_regmove                           ' $45: LD B,L
              long zk_regmove + ZK_HLOP                 ' $46: LD B,(HL)
              long zk_regmove                           ' $47: LD B,A
              long zk_regmove                           ' $48: LD C,B
              long zk_nextop                            ' $49: LD C,C (NOP)
              long zk_regmove                           ' $4A: LD C,D
              long zk_regmove                           ' $4B: LD C,E
              long zk_regmove                           ' $4C: LD C,H
              long zk_regmove                           ' $4D: LD C,L
              long zk_regmove + ZK_HLOP                 ' $4E: LD C,(HL)
              long zk_regmove                           ' $4F: LD C,A
              long zk_regmove                           ' $50: LD D,B
              long zk_regmove                           ' $51: LD D,C
              long zk_nextop                            ' $52: LD D,D (NOP)
              long zk_regmove                           ' $53: LD D,E
              long zk_regmove                           ' $54: LD D,H
              long zk_regmove                           ' $55: LD D,L
              long zk_regmove + ZK_HLOP                 ' $56: LD D,(HL)
              long zk_regmove                           ' $57: LD D,A
              long zk_regmove                           ' $58: LD E,B
              long zk_regmove                           ' $59: LD E,C
              long zk_regmove                           ' $5A: LD E,D
              long zk_nextop                            ' $5B: LD E,E (NOP)
              long zk_regmove                           ' $5C: LD E,H
              long zk_regmove                           ' $5D: LD E,L
              long zk_regmove + ZK_HLOP                 ' $5E: LD E,(HL)
              long zk_regmove                           ' $5F: LD E,A
              long zk_regmove                           ' $60: LD H,B
              long zk_regmove                           ' $61: LD H,C
              long zk_regmove                           ' $62: LD H,D
              long zk_regmove                           ' $63: LD H,E
              long zk_nextop                            ' $64: LD H,H (NOP)
              long zk_regmove                           ' $65: LD H,L
              long zk_regmove + ZK_HLOP                 ' $66: LD H,(HL)
              long zk_regmove                           ' $67: LD H,A
              long zk_regmove                           ' $68: LD L,B
              long zk_regmove                           ' $69: LD L,C
              long zk_regmove                           ' $6A: LD L,D
              long zk_regmove                           ' $6B: LD L,E
              long zk_regmove                           ' $6C: LD L,H
              long zk_nextop                            ' $6D: LD L,L (NOP)
              long zk_regmove + ZK_HLOP                 ' $6E: LD L,(HL)
              long zk_regmove                           ' $6F: LD L,A
              long zk_regmove + ZK_HLOP                 ' $70: LD (HL),B
              long zk_regmove + ZK_HLOP                 ' $71: LD (HL),C
              long zk_regmove + ZK_HLOP                 ' $72: LD (HL),D
              long zk_regmove + ZK_HLOP                 ' $73: LD (HL),E
              long zk_regmove + ZK_HLOP                 ' $74: LD (HL),H
              long zk_regmove + ZK_HLOP                 ' $75: LD (HL),L
              long zk_halt                              ' $76: HALT
              long zk_regmove + ZK_HLOP                 ' $77: LD (HL),A
              long zk_regmove                           ' $78: LD A,B
              long zk_regmove                           ' $79: LD A,C
              long zk_regmove                           ' $7A: LD A,D
              long zk_regmove                           ' $7B: LD A,E
              long zk_regmove                           ' $7C: LD A,H
              long zk_regmove                           ' $7D: LD A,L
              long zk_regmove + ZK_HLOP                 ' $7E: LD A,(HL)
              long zk_nextop                            ' $7F: LD A,A (NOP)
              long(zk_math8 + (%10_11_00_0000_1100_0_10_001_0<<10) )[6]' $80..$85: ADD A,[BCDEHL]
              long zk_math8 + (%10_11_00_0000_1100_0_10_001_0<<10) + ZK_HLOP ' $86: ADD A,(HL)
              long zk_math8 + (%10_11_00_0000_1100_0_10_001_0<<10) ' $87: ADD A,A
              long(zk_math8 + (%10_11_00_0000_1100_0_01_001_0<<10) )[6]' $88..$8D: ADC A,[BCDEHL]
              long zk_math8 + (%10_11_00_0000_1100_0_01_001_0<<10) + ZK_HLOP ' $8E: ADC A,(HL)
              long zk_math8 + (%10_11_00_0000_1100_0_01_001_0<<10) ' $8F: ADC A,A
              long(zk_math8 + (%10_11_00_0000_0011_0_10_001_0<<10) )[6]' $90..$95: SUB [BCDEHL]
              long zk_math8 + (%10_11_00_0000_0011_0_10_001_0<<10) + ZK_HLOP ' $96: SUB (HL)
              long zk_math8 + (%10_11_00_0000_0011_0_10_001_0<<10) ' $97: SUB A
              long(zk_math8 + (%10_11_00_0000_0011_0_01_001_0<<10) )[6]' $98..$9D: SBC A,[BCDEHL]
              long zk_math8 + (%10_11_00_0000_0011_0_01_001_0<<10) + ZK_HLOP ' $9E: SBC A,(HL)
              long zk_math8 + (%10_11_00_0000_0011_0_01_001_0<<10) ' $9F: SBC A,A
              long(zk_logic + (%000000_110_0<<10))[6]   ' $A0..$A5: AND [BCDEHL]
              long zk_logic + (%000000_110_0<<10) + ZK_HLOP ' $A6: AND (HL)
              long zk_logic + (%000000_110_0<<10)       ' $A7: AND A
              long(zk_logic + (%001000_011_0<<10))[6]   ' $A8..$AD: XOR [BCDEHL]
              long zk_logic + (%001000_011_0<<10) + ZK_HLOP ' $AE: XOR (HL)
              long zk_logic + (%001000_011_0<<10)       ' $AF: XOR A
              long(zk_logic + (%001000_101_0<<10))[6]   ' $B0..$B5: OR [BCDEHL]
              long zk_logic + (%001000_101_0<<10) + ZK_HLOP ' $B6: OR (HL)
              long zk_logic + (%001000_101_0<<10)       ' $B7: OR A
              long(zk_math8 + (%11_00_00_0000_0011_0_10_001_0<<10) )[6]' $B8..$BD: CP [BCDEHL]
              long zk_math8 + (%11_00_00_0000_0011_0_10_001_0<<10) + ZK_HLOP ' $BE: CP (HL)
              long zk_math8 + (%11_00_00_0000_0011_0_10_001_0<<10) ' $BF: CP A
              long zk_condret+(%0101_11_00_01_1110_0<<10) ' $C0: RET NZ
              long zk_poppair+(%0_0<<10)                  ' $C1: POP BC
              long zk_jump  + (%0101_11_01_01_1110_10<<10) ' $C2: JP NZ,imm16
              long zk_jump  + (%0101_11_01_11_1111_10<<10) ' $C3: JP imm16
              long zk_jump  + (%0000_11_01_01_1110_10<<10) ' $C4: CALL NZ,imm16
              long zk_pushbc+(%0_1110<<10)              ' $C5: PUSH BC
              long zk_immmath + (%10_11_00_0000_1100_0_10_00_0<<10) ' $C6: ADD A,imm8
              long zk_rst                               ' $C7: RST 00h
              long zk_condret+(%0101_11_00_00_1110_0<<10) ' $C8: RET Z
              long zk_ret + (%0101_11_00<<10)           ' $C9: RET
              long zk_jump  + (%0101_11_01_00_1110_10<<10)' $CA: JP Z,imm16
              long zk_bitprefix + ZK_HLOP               ' $CB: bit op prefix
              long zk_jump  + (%0000_11_01_00_1110_10<<10)' $CC: CALL Z,imm16
              long zk_jump  + (%0000_11_01_11_1111_10<<10)' $CD: CALL imm16
              long zk_immmath + (%10_11_00_0000_1100_0_01_00_0<<10) ' $CE: ADC A,imm8
              long zk_rst                               ' $CF: RST 08h
              long zk_condret+(%0101_11_00_01_1101_0<<10) ' $D0: RET NC
              long zk_poppair+(%01_0<<10)                 ' $D1: POP DE
              long zk_jump  + (%0101_11_01_01_1101_10<<10)' $D2: JP NC,imm16
              long zk_immio + (%00_00<<10)                ' $D3: OUT (imm8),A
              long zk_jump  + (%0000_11_01_01_1101_10<<10)' $D4: CALL NC,imm16
              long zk_pushde+(%0_110<<10)               ' $D5: PUSH DE
              long zk_immmath + (%10_11_00_0000_0011_0_10_00_0<<10) ' $D6: SUB imm8
              long zk_rst                               ' $D7: RST 10h
              long zk_condret+(%0101_11_00_00_1101_0<<10) ' $D8: RET C
              long zk_exx                               ' $D9: EXX
              long zk_jump  + (%0101_11_01_00_1101_10<<10)' $DA: JP C,imm16
              long zk_immio + (%00_11_00<<10)             ' $DB: IN A,(imm8)
              long zk_jump  + (%0000_11_01_00_1101_10<<10)' $DC: CALL C,imm16
              long zk_ixprefix                          ' $DD: IX prefix
              long zk_immmath + (%10_11_00_0000_0011_0_01_00_0<<10) ' $DE: SBC A,imm8
              long zk_rst                               ' $DF: RST 18h
              long zk_condret+(%0101_11_00_01_1011_0<<10) ' $E0: RET PO
              long zk_poppair+(%0011_0<<10)               ' $E1: POP HL
              long zk_jump  + (%0101_11_01_01_1011_10<<10)' $E2: JP PO,imm16
              long zk_ex_hlstk                          ' $E3: EX (SP),HL
              long zk_jump  + (%0000_11_01_01_1011_10<<10)' $E4: CALL PO,imm16
              long zk_pushhl+(%0_10<<10)                  ' E5: PUSH HL
              long zk_immlogic + (%000000_110_1_0<<10)  ' $E6: AND imm8
              long zk_rst                               ' $E7: RST 20h
              long zk_condret+(%0101_11_00_00_1011_0<<10) ' $E8: RET PE
              long zk_jump_indir                          ' $E9: JP (HL)
              long zk_jump  + (%0101_11_01_00_1011_10<<10)' $EA: JP PE,imm16
              long zk_ex_dehl                           ' $EB: EX DE,HL
              long zk_jump  + (%0000_11_01_00_1011_10<<10)' $EC: CALL PE,imm16
              long zk_extprefix + ZK_HLOP               ' $ED: extension prefix
              long zk_immlogic + (%001000_011_1_0<<10)  ' $EE: XOR imm8
              long zk_rst                               ' $EF: RST 28h
              long zk_condret+(%0101_11_00_01_0111_0<<10) ' $F0: RET P
              long zk_poppair+(%00_1111_0<<10)            ' $F1: POP AF
              long zk_jump  + (%0101_11_01_01_0111_10<<10)' $F2: JP P,imm16
              long zk_irqoff                              ' $F3: DI
              long zk_jump  + (%0000_11_01_01_0111_10<<10)' $F4: CALL P,imm16
              long zk_pushaf+(%0_11111_00<<10)            ' $F5: PUSH AF
              long zk_immlogic + (%001000_101_1_0<<10)  ' $F6: OR imm8
              long zk_rst                               ' $F7: RST 30h
              long zk_condret+(%0101_11_00_00_0111_0<<10) ' $F8: RET M
              long zk_hl_to_sp                            ' $F9: LD SP,(HL)
              long zk_jump  + (%0101_11_01_00_0111_10<<10)' $FA: JP M,imm16
              long zk_irqon                               ' $FB: EI
              long zk_jump  + (%0000_11_01_00_0111_10<<10)' $FC: CALL M,imm16
              long zk_iyprefix + (%10<<10)              ' $FD: IY prefix
              long zk_immmath + (%11_00_00_0000_0011_0_10_00_0<<10) ' $FE: CP imm8
              long zk_rst                               ' $FF: RST 38h

              ' PSRAM helper table. Must be at $300
              long $0000
              long $1111
              long $2222
              long $3333
              long $4444
              long $5555
              long $6666
              long $7777
              long $8888
              long $9999
              long $AAAA
              long $BBBB
              long $CCCC
              long $DDDD
              long $EEEE
              long $FFFF


zk_rolla      mov zk_tmp8,zk_accu
zk_shiftop
              andn zk_flags,#(1<<ZK_HALF_BIT)|(1<<ZK_NMODE_BIT)

              bitl zk_tmp8,#7 wcz  ' left + SRA
              bitz zk_tmp8,#7 addbits 1 ' only SRA
              bitl zk_tmp8,#0 wcz  ' right
              modc _set wc ' only SLL
              modc _clr wc ' only SLA

              testb zk_flags,#ZK_CARRY_BIT wc' only RL/RR
              bitz zk_flags,#ZK_CARRY_BIT

              rcl zk_tmp8,#1 wz   ' left
              bitc zk_tmp8,#8     ' right (not SRA/SRL)
              shr zk_tmp8,#1 wz   ' right

              setq #ZK_XYMASK
              setq #ZK_SIGNXYMASK
              muxq zk_flags,zk_tmp8

        _ret_ mov zk_accu,zk_tmp8

              bitz zk_flags,#ZK_ZERO_BIT
              test zk_tmp8,#$FF wc
        _ret_ bitnc zk_flags,#ZK_OVER_BIT


zk_cio
              mov zk_optmp1,zk_opcode
              and zk_optmp1,#7<<3
              cmp zk_optmp1,#6<<3 wz
              mov zk_tmp8,#0
        if_nz call #\zk_getry
              getbyte zk_ea,zk_debc,#0
zk_immio
              call #\zk_readcode
              mov zk_ea,zk_tmp8

              mov zk_tmp8,zk_accu
              jmp #\zk_portout

              call #\zk_portin
        _ret_ mov zk_accu,zk_tmp8

              and zk_tmp8,#$FF wcz
              bitz zk_flags,#ZK_ZERO_BIT
              bitnc zk_flags,#ZK_OVER_BIT
              andn zk_flags,#(1<<ZK_HALF_BIT)|(1<<ZK_NMODE_BIT)
              setq #ZK_SIGNXYMASK
              muxq zk_flags,zk_tmp8

              cmp zk_optmp1,#6<<3 wz
        if_z  ret
              jmp #\zk_setry




zk_incdec8
              call #\zk_getry
              mov zk_optmp0,#1
zk_math8
              call #\zk_getrz
zk_immmath
              call #\zk_readcode
              mov zk_optmp0,zk_tmp8
              mov zk_tmp8,zk_accu

              modc _clr wc
              testb zk_flags,#ZK_CARRY_BIT wc

              ' Flag helper gunk
              mov zk_optmp1,zk_tmp8

              addx zk_tmp8,zk_optmp0
              bitl zk_flags,#ZK_NMODE_BIT
              subx zk_tmp8,zk_optmp0
              bith zk_flags,#ZK_NMODE_BIT

              xor zk_optmp1,zk_tmp8
              test zk_tmp8,#$100 wc
              bitc zk_flags,#ZK_CARRY_BIT
              and zk_tmp8,#255 wz

              setq #ZK_SIGNXYMASK
              muxq zk_flags,zk_tmp8
              ' Special nonsense for CP
              setq #ZK_XYMASK
              muxq zk_flags,zk_optmp0

              mov zk_accu,zk_tmp8
              call #\zk_setry

              xor zk_optmp1,zk_optmp0
              bitz zk_flags,#ZK_ZERO_BIT
              testb zk_optmp1,#4 wc
              bitc zk_flags,#ZK_HALF_BIT
              test zk_optmp1,#$180 wc
        _ret_ bitc zk_flags,#ZK_OVER_BIT


zk_neg
              cmp zk_accu,#$80 wz
              bitz zk_flags,#ZK_OVER_BIT
              testb zk_accu,#4 wz
              subr zk_accu,#0 wc
              bitc zk_flags,#ZK_CARRY_BIT
              testb zk_accu,#4 xorz
              bitz zk_flags,#ZK_HALF_BIT
              and zk_accu,#$FF wz
              bitz zk_flags,#ZK_ZERO_BIT
              bith zk_flags,#ZK_NMODE_BIT
              setq #ZK_SIGNXYMASK
        _ret_ muxq zk_flags,zk_accu


zk_cpl
              xor zk_accu,#$FF
              or zk_flags,#(1<<ZK_HALF_BIT)|(1<<ZK_NMODE_BIT)
              setq #ZK_XYMASK
        _ret_ muxq zk_flags,zk_accu

zk_math16
              modc _clr wc
zk_cmath16
              testb zk_flags,#ZK_CARRY_BIT wc

              getword zk_tmp16,zk_debc,#0 ' get BC
              getword zk_tmp16,zk_debc,#1 ' get DE
              mov zk_tmp16,zk_temphl      ' get HL/I*
              mov zk_tmp16,zk_sp          ' get SP

              mov zk_optmp1,zk_temphl
              xor zk_optmp1,zk_tmp16

              addx zk_temphl,zk_tmp16
              bitl zk_flags,#ZK_NMODE_BIT
              subx zk_temphl,zk_tmp16
              bith zk_flags,#ZK_NMODE_BIT

              xor zk_optmp1,zk_temphl
              and zk_temphl,zk_ffffh wz

              bitz zk_flags,#ZK_ZERO_BIT
              test zk_optmp1,zk_18000h wc
              bitc zk_flags,#ZK_OVER_BIT

              getbyte pa,zk_temphl,#1
              setq #ZK_SIGNXYMASK
              setq #ZK_XYMASK
              muxq zk_flags,pa

              testb zk_optmp1,#12 wc
              bitc zk_flags,#ZK_HALF_BIT
              testb zk_optmp1,#16 wc
              bitc zk_flags,#ZK_CARRY_BIT

              add zk_cycles,#7

              altd zk_hlptr
        _ret_ mov 0-0,zk_temphl


zk_daa
              mov zk_optmp0,#$00
              mov zk_tmp8,zk_accu
              cmpr zk_tmp8,#$99 wc
              testb zk_flags,#ZK_CARRY_BIT orc
        if_c  add zk_optmp0,#$60
              bitc zk_flags,#ZK_CARRY_BIT
              getnib zk_optmp1,zk_tmp8,#0
              cmpr zk_optmp1,#$9 wc
              testb zk_flags,#ZK_HALF_BIT orc
        if_c  add zk_optmp0,#$06
              testb zk_flags,#ZK_NMODE_BIT wc
              sumc zk_accu,zk_optmp0
              and zk_accu,#255 wcz
              bitz zk_flags,#ZK_ZERO_BIT
              bitnc zk_flags,#ZK_OVER_BIT ' Parity?
              testb zk_accu,#4 wc
              testb zk_tmp8,#4 xorc
              bitc zk_flags,#ZK_HALF_BIT
              setq #ZK_SIGNXYMASK
        _ret_ muxq zk_flags,zk_accu


zk_immlogic
              call #\zk_readcode
zk_logic
              call #\zk_getrz

              and zk_accu,zk_tmp8 wcz
              or zk_accu,zk_tmp8 wcz
              xor zk_accu,zk_tmp8 wcz

              bitnc zk_flags,#ZK_OVER_BIT ' parity
              bitz  zk_flags,#ZK_ZERO_BIT
              andn  zk_flags,#(1<<ZK_CARRY_BIT)|(1<<ZK_NMODE_BIT)|(1<<ZK_HALF_BIT)
              bith  zk_flags,#ZK_HALF_BIT ' Only for AND
              setq #ZK_SIGNXYMASK
        _ret_ muxq zk_flags,zk_accu


zk_pushaf
              getbyte zk_tmp16,zk_accu,#0
              rolbyte zk_tmp16,zk_flags,#0

zk_incdec16
              add zk_cycles,#2
zk_pushbc     getword zk_tmp16,zk_debc,#0 ' get BC
zk_pushde     getword zk_tmp16,zk_debc,#1 ' get DE
zk_pushhl     mov zk_tmp16,zk_temphl      ' get HL/I*
              mov zk_tmp16,zk_sp          ' get SP

              jmp #\zk_push16

              add zk_tmp16,#1
              sub zk_tmp16,#1

zk_loadimm16
              call #\zk_readcode16
              mov zk_ea,zk_tmp16   ' for LDs with (imm16)
              call #\zk_read16     ' ^^
              jmp #\zk_write16     ' ^^
zk_poppair
              call #\zk_pop16

        _ret_ setword zk_debc,zk_tmp16,#0 ' set BC
        _ret_ setword zk_debc,zk_tmp16,#1 ' set DE
              altd zk_hlptr
        _ret_ setword zk_sp,zk_tmp16,#0   ' set SP/HL/I*

              getbyte zk_accu,zk_tmp16,#1   ' set A
        _ret_ getbyte zk_flags,zk_tmp16,#0  ' set F




zk_jr         '' JR and DJNZ
              call #\zk_readcode

              getbyte pa,zk_debc,#1
              sub pa,#1 wz
              setbyte zk_debc,pa,#1
              add zk_cycles,#1

              testb zk_flags,#ZK_ZERO_BIT wz
              testb zk_flags,#ZK_CARRY_BIT wz

              modz _nz wz
        if_z  call #\zk_nextop
              ' branch taken
              add zk_cycles,#5
              signx zk_tmp8,#7
        _ret_ add zk_pc,zk_tmp8

zk_exx    '' EXX
              xor zk_debc,zk_altdebc
              xor zk_altdebc,zk_debc
              xor zk_debc,zk_altdebc
              ' Note: not affected by IX/IY substitution
              xor zk_hl,zk_althl
              xor zk_althl,zk_hl
        _ret_ xor zk_hl,zk_althl

zk_ex_dehl    '' EX DE,HL
              ' Note: not affected by IX/IY substitution
              getword zk_optmp0,zk_debc,#1
              setword zk_debc,zk_hl,#1
        _ret_ mov zk_hl,zk_optmp0


zk_ex_af  '' EX AF,AF'
              xor zk_accu,zk_altaccu
              xor zk_altaccu,zk_accu
              xor zk_accu,zk_altaccu
              xor zk_flags,zk_altflags
              xor zk_altflags,zk_flags
        _ret_ xor zk_flags,zk_altflags

zk_ex_hlstk '' EX (SP),HL
              add zk_cycles,#3 ' Should be 19. 19 - 4 - 4*3 = 3
              mov zk_ea,zk_sp
              call #\zk_read16
              altd zk_hlptr
              mov 0-0,zk_tmp16
              mov zk_tmp16,zk_temphl
              jmp #\zk_write16

zk_ld_abs16 '' LD HL,(imm16) and LD (imm16),HL
              call #\zk_readcode16
              mov zk_ea,zk_tmp16

              getword zk_tmp16,zk_debc,#0 ' get BC
              getword zk_tmp16,zk_debc,#1 ' get DE
              mov zk_tmp16,zk_temphl ' get HL/I*
              mov zk_tmp16,zk_sp ' get SP
              jmp #\zk_write16

              call #\zk_read16
        _ret_ setword zk_debc,zk_tmp16,#0 ' set BC
        _ret_ setword zk_debc,zk_tmp16,#1 ' set DE
              altd zk_hlptr
        _ret_ mov zk_sp,zk_tmp16


zk_scf
              modc _clr wc
zk_ccf
              testb zk_flags,#ZK_CARRY_BIT wc
              bitnc zk_flags,#ZK_CARRY_BIT
              bitc  zk_flags,#ZK_HALF_BIT
              bitl  zk_flags,#ZK_NMODE_BIT
              setq #ZK_XYMASK
        _ret_ muxq zk_flags,zk_accu

zk_ld_abs    '' LD A,(imm16) and LD (imm16),A
              call #\zk_readcode16
              mov zk_ea,zk_tmp16
zk_a_and_ptr '' A and (BC)/(DE) ops
              getword zk_ea,zk_debc,#0 ' get BC
              getword zk_ea,zk_debc,#1 ' get DE
              call #\zk_read8
        _ret_ mov zk_accu,zk_tmp8
              mov zk_tmp8,zk_accu
              jmp #\zk_write8

zk_regmove
              push #zk_setry
              jmp #\zk_getrz

zk_loadimm8
              push #zk_setry
              jmp #\zk_readcode


zk_halt
              '' TODO
              pollse1 wc
              testb zk_irqenable,#ZK_IFF1_BIT andc
        if_nc incmod zk_refresh,#127
        if_nc jmp #$
              ret



              fit $400


DAT ' ZiKore Z80 init code
              orgh
zk_init
              setq #495
              rdlong 0,##@zk_cogbase
              setq2 #511
              rdlong 0,##@zk_lutbase

zk_doreset
              debug("Z80 reset START")
              mov zk_pc,#0
              'mov zk_accu,#$FF
              'mov zk_flags,#$FF
              'mov zk_sp,##$FFFF
              mov zk_irqenable,#0
              mov zk_irqhook,#0
              mov zk_refresh,#0
              mov zk_refreshhi,#0
              mov zk_ivector,#0
              mov zk_bank0ptr,##@m1_rom
              mov zk_bank1ptr,##@m1_rom
              mov zk_bank2ptr,##@m1_rom
              mov zk_bank3ptr,##@m1_rom
              debug("Z80 reset DONE")

              jmp #zk_nextop


DAT ' MEMORY
              orgh
vshrink_lookup
              file "SHRINK.BIN"



mk_vectorcache_bios
              long 0[32]
              long 0[32] ' even when BIOS vectors are banked in, it's only the first 32
mk_vectorcache_game
              long 0[64]

              orgh $0_F800
z80_ram
              byte 0[$800]

              orgh $1_0000
main_ram
              byte 0[$1_0000] ' 68k RAM

              byte 0[16] ' padding
mk_romio_area
              byte 0[16]
              byte 0[16] ' padding
mk_romque_area
              byte 0[256]


vram_low
              word 0[$8000]
vram_high
              word 0[$800] ' Note: reordered for speed


draw_buffer
              long 0[16]
              long 0[(320+16)*4]

palette32
              long 0[256*16*2] ' Palette has two banks for some reason

' temporary data associated with sprite rendering (4 lines * 96 sprites))
' format is as such:
'   2 longs buffer area for CROM data
'   long CROM pointer (minus 1: end of active list)
'   word %PPPP_PPPP_SSSS_xxxH
'     P -> palette
'     S -> H shrink value
'     H -> mirror flag
'   word X position + 15
spr_buffer    long 0[96*4*4]


              orgh UPPER_LOAD-$2_0000
fix_tiles
              file "MENUFIX.DAT"

              orgh UPPER_LOAD
m1_rom ' M1 ROM overwrites upcode
upcode_base
              file "neoyume_upper.binary"
